# Decisões de Projeto: 05-07-2025 - 

## Prompts mais importantes

1. 

Vamos continuar a implementação de observabilidade. Observe que eu tenho as pastas 'observabilidade' e 'middleware' .

├── app
│   ├── api
│   │   ├── endpoints.py
│   │   ├── endpoints_videos.py
│   │   ├── routes.py
│   │   └── schemas.py
│   ├── auth
│   │   ├── dependencies.py
│   │   └── schemas.py
│   ├── chroma
│   │   ├── buscador_segmentos.py
│   │   ├── buscador_tags.py
│   │   ├── factory.py
│   │   └── ingest_from_jsonl.py
│   ├── core
│   │   └── logger.py
│   ├── db
│   │   └── dermasync_chroma
│   │       └── chroma.sqlite3
│   ├── firestore
│   │   ├── client.py
│   │   └── persistencia.py
│   ├── llm
│   │   └── gemini.py
│   ├── middleware
│   │   └── log_requests.py
│   ├── observabilidade
│   │   ├── exemplos
│   │   │   └── relato_log.jsonl
│   │   ├── log_parser.py
│   │   ├── logger.py
│   │   ├── mermaid_generator.py
│   │   └── schemas.py
│   ├── pipeline
│   │   ├── a_extracao_bruta
│   │   │   └── gerar_jsonl_bruto.py
│   │   ├── B_enriquecimento
│   │   │   ├── templates
│   │   │   ├── enriquecer_metadados.py
│   │   │   ├── extrair_detalhes_terapeuticos.py
│   │   │   ├── extrair_tags_llm.py
│   │   │   └── gerar_microdepoimento.py
│   │   ├── C_segmentacao

...
│   ├── test_healthcheck.py
│   ├── test_integracao_01_02.py
│   ├── test_pipeline_01_jsonlbruto.py
│   ├── test_pipeline_02_enriquecer_metadados.py
│   ├── test_relatos.py
│   ├── utils.py
│   └── validar_jsonl.py
├── .coverage
├── .gcloudignore
├── .pylintrc
├── CHANGELOG.md
├── clean_docker_cache.bat
├── deploy_dermasync_api.bat
├── dermasync-backend.json
├── dermasync-key.json
├── gerar_diagrama.py
├── info_dev.md
├── key.json
├── pylint_report.txt
├── report.json
├── test_report.md
└── tokens.json
O objetivo é atingir a meta abaixo
Transformar a branch infra/observability-sprint1 em um modulo para observabilidade que sera um modulo de monitoramento. E tambem vai gerar um diagrama a partir de um mermaid
gerado automaticamente a partir da leitura dos logs. Há logs especificos para documentacao automatica da arquitetura.

Nome do projeto: log2arch (pode mudar depois)
Objetivo: Transformar logs estruturados JSONL em:

Diagramas de sequência (Mermaid)

Métricas de performance

Alertas de falha

Documentação semi-automática da arquitetura

Logs em geral de INFO e DEBUG

----

Vamos concentrar os diretorios observabilidade e middleware em um só. Ao final de 1h30 de estudos, quero sair com esse deploy sendo realizado já no github actions tudo bonitinho diariamente!

---

Me diga quais outros detalhes que precisa para me devolver resposta precisa

## == RESPOSTA o3-mini-high ==

```code

Formato e conteúdo dos logs JSONL
 linhas de exemplo 
{"timestamp": "2025-07-04T14:00:01Z", "request_id": "req_001", "caller": "frontend", "callee": "relato_service", "operation": "POST /enviar-relato", "status_code": 200, "duration_ms": 122}
{"timestamp": "2025-07-04T14:00:02Z", "request_id": "req_001", "caller": "relato_service", "callee": "firebase_storage", "operation": "upload_imagem", "status_code": 200, "duration_ms": 321}
{"timestamp": "2025-07-04T14:00:03Z", "request_id": "req_001", "caller": "relato_service", "callee": "llm_extractor", "operation": "extrair_tags", "status_code": 200, "duration_ms": 1522}
{"timestamp": "2025-07-04T14:00:04Z", "request_id": "req_001", "caller": "llm_extractor", "callee": "chromadb", "operation": "persistir_vetor", "status_code": 200, "duration_ms": 88}

Escopo dos diagramas Mermaid

Quais fluxos exatos você quer representar em sequência?
R.: pode ser de Diagramas de Sequência Diagramas de Estado – Para máquinas de estado ou transições.Mapas Mentais (Mindmaps) – Para organizar ideias.
Todas as chamadas HTTP entre os serviços?
R.: sim
Fluxo do pipeline RAG interno?
R.: Sim
Apenas endpoints críticos?
R.: sim
Métricas de performance desejadas
R.: a mais usual 
Latência por endpoint (p50/p95/p99)?
R.: a mais alta
Taxa de erros (5xx, exceptions)?
R.: sim
Contadores personalizados (nº de logs, de micro-depoimentos gerados)?

Quais thresholds para alertas (e.g. latência >500 ms)?
R.: 1 segundo por enquanto
Stack de observabilidade e alertas

Você já tem ou quer usar Prometheus + Grafana, ELK (Elasticsearch/Kibana), ou outro?
R.: Vamos deixar local ou no proprio firebase por enquanto. 
Onde os dados serão enviados (endpoint push, agent local)?
R.: Deixar mockado para o futuro
Para onde enviar alertas (Slack, e-mail, Teams)? Quais credenciais ou webhooks já estão configurados?
R.: Deixar isso em lista futura 
Unificação de diretórios

Como devem ficar as rotas de import após mover middleware/log_requests.py para dentro de observabilidade/?
R.: Pode me sugerir ?
Qual o namespace final da package — log2arch?
R.: archlog-sync
Detalhes do deploy via GitHub Actions

Qual runner (ubuntu-latest, windows-latest)?
R: ubuntu-latest
Quais secrets já definiram (e.g. PROM_PUSH_URL, SLACK_WEBHOOK)?
R:FIREBASE_CREDENTIALS,
FIREBASE_CREDENTIALS_BASE64,
FIREBASE_CREDENTIALS_JSON,
FIREBASE_STORAGE_BUCKET,
GEMINI_API_KEY,
GOOGLE_CLOUD_PROJECT

Que artefatos devem ser gerados e versionados no repositório (diagramas .mmd, relatórios de métricas em JSON, alertas de falha)?
R: Diagramas .mmd, relatórios de métricas json, alertas falha
Em que horário/daily schedule você quer rodar (e.g. toda madruga às 02:00 BRT)?
R: isso, esse horario tá otimo
```

## Efeitos