============================= test session starts =============================
platform win32 -- Python 3.11.4, pytest-8.4.1, pluggy-1.6.0
rootdir: D:\workspace_projects_001\dermasync-api
configfile: pytest.ini
plugins: anyio-4.9.0, langsmith-0.4.5, asyncio-1.0.0, cov-6.2.1, html-4.1.1, json-report-1.5.0, logger-1.1.1, metadata-3.1.1, mock-3.15.1
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function

----------------------------- live log collection -----------------------------
2026-01-27 11:57:24 [INFO] Current Python path: ['D:\\workspace_projects_001\\dermasync-api', 'D:\\workspace_projects_001\\dermasync-api\\tests\\services', 'D:\\workspace_projects_001\\dermasync-api\\tests\\services\\readmodels', 'D:\\workspace_projects_001\\dermasync-api\\tests\\services\\effects', 'D:\\workspace_projects_001\\dermasync-api\\tests\\routes', 'D:\\workspace_projects_001\\dermasync-api', 'D:\\workspace_projects_001\\dermasync-api\\tests\\integration', 'D:\\workspace_projects_001\\dermasync-api\\tests\\infra\\retry', 'D:\\workspace_projects_001\\dermasync-api\\tests\\domain', 'D:\\workspace_projects_001\\dermasync-api\\tests\\domain\\ux_effects', 'D:\\workspace_projects_001\\dermasync-api\\tests\\domain\\relato', 'D:\\workspace_projects_001\\dermasync-api\\tests\\domain', 'D:\\workspace_projects_001\\dermasync-api\\tests\\domain\\effects', 'D:\\workspace_projects_001\\dermasync-api\\tests\\core\\projections', 'D:\\workspace_projects_001\\dermasync-api\\tests\\auth', 'D:\\workspace_projects_001\\dermasync-api\\tests\\application', 'D:\\workspace_projects_001\\dermasync-api', 'D:\\workspace_projects_001\\dermasync-api\\venv\\Scripts\\pytest.exe', 'C:\\Python311\\python311.zip', 'C:\\Python311\\DLLs', 'C:\\Python311\\Lib', 'C:\\Python311', 'D:\\workspace_projects_001\\dermasync-api\\venv', 'D:\\workspace_projects_001\\dermasync-api\\venv\\Lib\\site-packages', 'D:\\workspace_projects_001\\dermasync-api\\app\\pipeline']
collected 175 items

tests/application/test_relato_progress_service.py::test_service_returns_progress_with_no_effects PASSED [  0%]
tests/application/test_relato_progress_service.py::test_service_passes_effects_to_domain_correctly PASSED [  1%]
tests/application/test_relato_progress_service.py::test_service_calls_repository_with_correct_relato_id PASSED [  1%]
tests/application/test_relato_progress_service.py::test_service_propagates_repository_errors PASSED [  2%]
tests/application/test_relato_progress_stabilization_service.py::test_job_returns_snapshot_if_stable_exists PASSED [  2%]
tests/application/test_relato_progress_stabilization_service.py::test_job_persists_snapshot_when_progress_is_stable FAILED [  3%]
tests/auth/test_auth_cenarios.py::test_get_me_usuario_nao_encontrado 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:26 [INFO] Auth token payload preview: sub=7a9d65cb-8434-4fae-822f-bf111cf83020 role=usuario_logado type=access
2026-01-27 11:57:26 [WARNING] auth_service.get_user_from_db levantou HTTPException: Usu├írio n├úo encontrado. (status=401)
2026-01-27 11:57:26 [INFO] AUTH REJECT: usu├írio n├úo encontrado (sub=7a9d65cb-8434-4fae-822f-bf111cf83020). (service_used=True)
2026-01-27 11:57:26 [INFO] GET /auth/me 127.0.0.1 -> 401 (112.5ms) body_len=0
2026-01-27 11:57:26 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [  4%]
tests/auth/test_auth_cenarios.py::test_get_me_usuario_desativado_apos_login 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:26 [INFO] Auth token payload preview: sub=c0bd67af-1a82-4977-b19a-e892c01a494e role=usuario_logado type=access
2026-01-27 11:57:26 [INFO] AUTH FORBID: usu├írio inativo user=c0bd67af-1a82-4977-b19a-e892c01a494e
2026-01-27 11:57:26 [INFO] GET /auth/me 127.0.0.1 -> 403 (21.7ms) body_len=0
2026-01-27 11:57:26 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 403 Forbidden"
PASSED                                                                   [  4%]
tests/auth/test_auth_cenarios.py::test_external_login_com_usuario_inativo 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:26 [INFO] POST /auth/external-login 127.0.0.1 -> 403 (39.3ms) body_len=40
2026-01-27 11:57:26 [INFO] HTTP Request: POST http://test/auth/external-login "HTTP/1.1 403 Forbidden"
PASSED                                                                   [  5%]
tests/auth/test_auth_cenarios.py::test_role_mismatch_entre_token_e_db 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:26 [INFO] Auth token payload preview: sub=7ead94a8-97e0-44c8-b5c5-79853196df47 role=admin type=access
2026-01-27 11:57:26 [WARNING] AUTH REJECT: mismatch entre role do token (admin) e role do DB (usuario_logado) para user=7ead94a8-97e0-44c8-b5c5-79853196df47
2026-01-27 11:57:26 [INFO] GET /auth/me 127.0.0.1 -> 401 (20.8ms) body_len=0
2026-01-27 11:57:26 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [  5%]
tests/auth/test_auth_cenarios.py::test_get_me_com_auth_header_invalido[None-Not authenticated] 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:26 [INFO] AUTH REJECT: Authorization header ausente.
2026-01-27 11:57:26 [INFO] GET /auth/me 127.0.0.1 -> 401 (8.4ms) body_len=0
2026-01-27 11:57:26 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [  6%]
tests/auth/test_auth_cenarios.py::test_get_me_com_auth_header_invalido[Token my-invalid-token-Not authenticated] 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:26 [INFO] AUTH REJECT: Authorization header presente mas esquema n├úo ├® Bearer (esquema=token).
2026-01-27 11:57:26 [INFO] GET /auth/me 127.0.0.1 -> 401 (13.6ms) body_len=0
2026-01-27 11:57:26 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [  6%]
tests/auth/test_auth_cenarios.py::test_get_me_com_auth_header_invalido[Bearer -Token inv\xe1lido.] 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:27 [INFO] AUTH REJECT: Bearer header presente mas token vazio.
2026-01-27 11:57:27 [INFO] GET /auth/me 127.0.0.1 -> 401 (16.9ms) body_len=0
2026-01-27 11:57:27 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [  7%]
tests/auth/test_auth_cenarios.py::test_get_me_com_auth_header_invalido[Bearer-Token inv\xe1lido.] 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:27 [INFO] AUTH REJECT: Bearer header presente mas token vazio.
2026-01-27 11:57:27 [INFO] GET /auth/me 127.0.0.1 -> 401 (14.9ms) body_len=0
2026-01-27 11:57:27 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [  8%]
tests/auth/test_auth_flow.py::test_auth_flow_end_to_end_and_log_stdout 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:27 [WARNING] (trapped) error reading bcrypt version
Traceback (most recent call last):
  File "D:\workspace_projects_001\dermasync-api\venv\Lib\site-packages\passlib\handlers\bcrypt.py", line 620, in _load_backend_mixin
    version = _bcrypt.__about__.__version__
              ^^^^^^^^^^^^^^^^^
AttributeError: module 'bcrypt' has no attribute '__about__'
2026-01-27 11:57:27 [INFO] Tentativa de login recebida para o e-mail: test+e5fa7d61@local.com
2026-01-27 11:57:28 [INFO] Token de acesso e refresh emitidos para o usu├írio: test+e5fa7d61@local.com
2026-01-27 11:57:29 [INFO] POST /auth/login testclient -> 200 (1143.0ms) body_len=58
2026-01-27 11:57:29 [INFO] HTTP Request: POST http://testserver/auth/login "HTTP/1.1 200 OK"
2026-01-27 11:57:29 [INFO] Auth token payload preview: sub=9b03415d-bf33-416c-90f5-f5fa60409811 role=usuario_logado type=access
2026-01-27 11:57:31 [WARNING] auth_service.get_user_from_db levantou HTTPException: Usu├írio n├úo encontrado. (status=401)
2026-01-27 11:57:31 [INFO] AUTH OK: usu├írio autenticado user=9b03415d-bf33-416c-90f5-f5fa60409811 role=usuario_logado (service_used=True)
2026-01-27 11:57:31 [INFO] GET /me/profile testclient -> 200 (2041.3ms) body_len=0
2026-01-27 11:57:31 [INFO] HTTP Request: GET http://testserver/me/profile "HTTP/1.1 200 OK"
PASSED                                                                   [  8%]
tests/auth/test_auth_hardening.py::test_auth_refresh_expired PASSED      [  9%]
tests/auth/test_auth_hardening.py::test_auth_refresh_reuse PASSED        [  9%]
tests/auth/test_auth_hardening.py::test_auth_revoke_all_tokens PASSED    [ 10%]
tests/auth/test_auth_logout.py::test_auth_logout_revokes_refresh_token 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:34 [INFO] POST /auth/logout 127.0.0.1 -> 200 (78.9ms) body_len=106
2026-01-27 11:57:34 [INFO] HTTP Request: POST http://test/auth/logout "HTTP/1.1 200 OK"
PASSED                                                                   [ 10%]
tests/auth/test_auth_logout.py::test_auth_logout_idempotent 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:34 [INFO] POST /auth/logout 127.0.0.1 -> 200 (48.6ms) body_len=106
2026-01-27 11:57:34 [INFO] HTTP Request: POST http://test/auth/logout "HTTP/1.1 200 OK"
2026-01-27 11:57:34 [INFO] POST /auth/logout 127.0.0.1 -> 200 (14.5ms) body_len=106
2026-01-27 11:57:34 [INFO] HTTP Request: POST http://test/auth/logout "HTTP/1.1 200 OK"
PASSED                                                                   [ 11%]
tests/auth/test_auth_logout.py::test_auth_logout_all_revokes_all_and_invalidates_access 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:35 [INFO] POST /auth/logout-all 127.0.0.1 -> 200 (56.9ms) body_len=0
2026-01-27 11:57:35 [INFO] HTTP Request: POST http://test/auth/logout-all "HTTP/1.1 200 OK"
PASSED                                                                   [ 12%]
tests/auth/test_auth_logout.py::test_auth_logout_all_requires_auth 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:35 [INFO] AUTH REJECT: Authorization header ausente.
2026-01-27 11:57:35 [INFO] POST /auth/logout-all 127.0.0.1 -> 401 (10.9ms) body_len=0
2026-01-27 11:57:35 [INFO] HTTP Request: POST http://test/auth/logout-all "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [ 12%]
tests/auth/test_auth_refresh.py::test_refresh_token_sucesso 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:35 [INFO] POST /auth/refresh 127.0.0.1 -> 200 (5.9ms) body_len=201
2026-01-27 11:57:35 [INFO] HTTP Request: POST http://test/auth/refresh "HTTP/1.1 200 OK"
PASSED                                                                   [ 13%]
tests/auth/test_auth_refresh.py::test_refresh_token_expirado 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:35 [INFO] POST /auth/refresh 127.0.0.1 -> 401 (11.2ms) body_len=38
2026-01-27 11:57:35 [INFO] HTTP Request: POST http://test/auth/refresh "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [ 13%]
tests/auth/test_auth_refresh.py::test_refresh_com_access_token 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:36 [INFO] POST /auth/refresh 127.0.0.1 -> 401 (9.5ms) body_len=37
2026-01-27 11:57:36 [INFO] HTTP Request: POST http://test/auth/refresh "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [ 14%]
tests/auth/test_auth_refresh.py::test_refresh_token_usuario_inativo 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:36 [INFO] POST /auth/refresh 127.0.0.1 -> 403 (9.8ms) body_len=48
2026-01-27 11:57:36 [INFO] HTTP Request: POST http://test/auth/refresh "HTTP/1.1 403 Forbidden"
PASSED                                                                   [ 14%]
tests/auth/test_auth_refresh_integration.py::test_login_and_refresh PASSED [ 15%]
tests/auth/test_auth_rotas.py::test_external_login_sucesso 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:36 [INFO] POST /auth/external-login 127.0.0.1 -> 200 (6.0ms) body_len=40
2026-01-27 11:57:36 [INFO] HTTP Request: POST http://test/auth/external-login "HTTP/1.1 200 OK"
PASSED                                                                   [ 16%]
tests/auth/test_auth_rotas.py::test_get_me_sem_token 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:37 [INFO] AUTH REJECT: Authorization header ausente.
2026-01-27 11:57:37 [INFO] GET /auth/me 127.0.0.1 -> 401 (30.7ms) body_len=0
2026-01-27 11:57:37 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [ 16%]
tests/auth/test_auth_rotas.py::test_get_me_com_token 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:37 [INFO] GET /auth/me 127.0.0.1 -> 200 (46.2ms) body_len=0
2026-01-27 11:57:37 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 200 OK"
PASSED                                                                   [ 17%]
tests/auth/test_auth_rotas.py::test_get_me_com_token_expirado 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:37 [WARNING] JWT expired: Signature has expired
2026-01-27 11:57:37 [WARNING] AUTH REJECT: falha ao decodificar token: Token expirado.
2026-01-27 11:57:37 [INFO] GET /auth/me 127.0.0.1 -> 401 (11.9ms) body_len=0
2026-01-27 11:57:37 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [ 17%]
tests/auth/test_auth_rotas.py::test_get_me_com_token_invalido 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:37 [WARNING] JWT invalid: Signature verification failed
2026-01-27 11:57:37 [WARNING] AUTH REJECT: falha ao decodificar token: Token inv├ílido.
2026-01-27 11:57:37 [INFO] GET /auth/me 127.0.0.1 -> 401 (17.1ms) body_len=0
2026-01-27 11:57:37 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [ 18%]
tests/auth/test_auth_rotas.py::test_get_me_com_token_role_adulterada 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:37 [INFO] Auth token payload preview: sub=test_tampered_role_user role=admin type=access
2026-01-27 11:57:37 [WARNING] AUTH REJECT: mismatch entre role do token (admin) e role do DB (usuario_logado) para user=test_tampered_role_user
2026-01-27 11:57:37 [INFO] GET /auth/me 127.0.0.1 -> 401 (16.2ms) body_len=0
2026-01-27 11:57:37 [INFO] HTTP Request: GET http://test/auth/me "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [ 18%]
tests/auth/test_auth_rotas.py::test_external_login_usuario_inativo 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:37 [INFO] POST /auth/external-login 127.0.0.1 -> 403 (5.6ms) body_len=49
2026-01-27 11:57:37 [INFO] HTTP Request: POST http://test/auth/external-login "HTTP/1.1 403 Forbidden"
PASSED                                                                   [ 19%]
tests/auth/test_auth_rotas.py::test_external_login_sem_provider_token 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:37 [INFO] POST /auth/external-login 127.0.0.1 -> 422 (40.2ms) body_len=2
2026-01-27 11:57:37 [INFO] HTTP Request: POST http://test/auth/external-login "HTTP/1.1 422 Unprocessable Entity"
PASSED                                                                   [ 20%]
tests/core/projections/test_progress_projector.py::test_progress_with_no_effects_all_pending PASSED [ 20%]
tests/core/projections/test_progress_projector.py::test_progress_step_completed PASSED [ 21%]
tests/core/projections/test_progress_projector.py::test_progress_step_failed_sets_error PASSED [ 21%]
tests/domain/effects/test_retry_ux_effects.py::test_retry_emits_retry_ux_effect PASSED [ 22%]
tests/domain/effects/test_retry_ux_effects.py::test_retry_executes_failed_effects PASSED [ 22%]
tests/domain/effects/test_retry_ux_effects.py::test_retry_endpoint_returns_202 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:37 [INFO] Fetched 6 failed EffectResults for relato=relato-123
2026-01-27 11:57:37 [INFO] POST /relatos/relato-123/retry 127.0.0.1 -> 202 (124.6ms) body_len=0
2026-01-27 11:57:37 [INFO] HTTP Request: POST http://test/relatos/relato-123/retry "HTTP/1.1 202 Accepted"
PASSED                                                                   [ 23%]
tests/domain/effects/test_retry_ux_effects.py::test_retry_endpoint_returns_ux_effect 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:37 [INFO] Fetched 6 failed EffectResults for relato=relato-123
2026-01-27 11:57:37 [INFO] POST /relatos/relato-123/retry 127.0.0.1 -> 202 (100.9ms) body_len=0
2026-01-27 11:57:37 [INFO] HTTP Request: POST http://test/relatos/relato-123/retry "HTTP/1.1 202 Accepted"
FAILED                                                                   [ 24%]
tests/domain/enrichment/test_enriched_metadata_v2_validator.py::test_valid_payload_passes_validation FAILED [ 24%]
tests/domain/enrichment/test_enriched_metadata_v2_validator.py::test_extra_field_fails FAILED [ 25%]
tests/domain/enrichment/test_enriched_metadata_v2_validator.py::test_invalid_tag_fails PASSED [ 25%]
tests/domain/enrichment/test_enriched_metadata_v2_validator.py::test_invalid_signal_fails PASSED [ 26%]
tests/domain/enrichment/test_enriched_metadata_v2_validator.py::test_invalid_body_region_fails PASSED [ 26%]
tests/domain/enrichment/test_enriched_metadata_v2_validator.py::test_confidence_out_of_range_fails PASSED [ 27%]
tests/domain/enrichment/test_enriched_metadata_v2_validator.py::test_summary_too_long_fails PASSED [ 28%]
tests/domain/enrichment/test_enriched_metadata_v2_validator.py::test_missing_required_field_fails PASSED [ 28%]
tests/domain/relato/test_create_relato.py::test_criar_relato_estado_inicial FAILED [ 29%]
tests/domain/relato/test_create_relato.py::test_negar_criacao_relato_existente FAILED [ 29%]
tests/domain/relato/test_create_relato.py::test_post_relatos_success_runs_domain_and_executes_effects 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:38 [INFO] POST /relatos/ testclient -> 201 (21.0ms) body_len=111
2026-01-27 11:57:38 [INFO] HTTP Request: POST http://testserver/relatos/ "HTTP/1.1 201 Created"
FAILED                                                                   [ 30%]
tests/domain/relato/test_create_relato.py::test_post_relatos_admin_is_allowed_by_domain 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:38 [INFO] Executando efeitos do relato | total=2
2026-01-27 11:57:38 [INFO] ADAPTER: Persistindo relato c739b07cf3fa457cb0398f8c005930e8 | owner=admin-123 status=created
2026-01-27 11:57:38 [INFO] Executando UploadImagesEffect | relato=c739b07cf3fa457cb0398f8c005930e8
2026-01-27 11:57:38 [INFO] ADAPTER: Registrando image_refs do relato c739b07cf3fa457cb0398f8c005930e8 | stages=['antes', 'durante', 'depois']
2026-01-27 11:57:39 [INFO] POST /relatos/ testclient -> 201 (685.4ms) body_len=114
2026-01-27 11:57:39 [INFO] HTTP Request: POST http://testserver/relatos/ "HTTP/1.1 201 Created"
PASSED                                                                   [ 30%]
tests/domain/relato/test_create_relato.py::test_executor_called_when_admin_creates_relato 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:39 [INFO] POST /relatos/ testclient -> 201 (11.8ms) body_len=114
2026-01-27 11:57:39 [INFO] HTTP Request: POST http://testserver/relatos/ "HTTP/1.1 201 Created"
PASSED                                                                   [ 31%]
tests/domain/relato/test_create_relato.py::test_create_relato_emits_typed_effects FAILED [ 32%]
tests/domain/relato/test_create_relato.py::test_create_relato_initial_state_is_created FAILED [ 32%]
tests/domain/relato/test_create_relato_decision.py::test_create_relato_allowed_from_initial_state FAILED [ 33%]
tests/domain/relato/test_create_relato_decision.py::test_create_relato_denied_when_already_exists FAILED [ 33%]
tests/domain/relato/test_create_relato_decision.py::test_create_relato_denied_from_any_existing_state FAILED [ 34%]
tests/domain/relato/test_create_relato_decision.py::test_create_relato_effects_structure FAILED [ 34%]
tests/domain/relato/test_invalid_transitions.py::test_negar_submissao_estado_error PASSED [ 35%]
tests/domain/relato/test_invalid_transitions.py::test_negar_submissao_estado_processado PASSED [ 36%]
tests/domain/relato/test_invalid_transitions.py::test_negar_aprovacao_estado_draft FAILED [ 36%]
tests/domain/relato/test_invalid_transitions.py::test_negar_aprovacao_estado_processing PASSED [ 37%]
tests/domain/relato/test_invalid_transitions.py::test_negar_rejeicao_estado_draft FAILED [ 37%]
tests/domain/relato/test_invalid_transitions.py::test_negar_rejeicao_estado_processing PASSED [ 38%]
tests/domain/relato/test_invalid_transitions.py::test_negar_marcar_como_processado_estado_draft FAILED [ 38%]
tests/domain/relato/test_permissions.py::test_admin_pode_aprovar_relato PASSED [ 39%]
tests/domain/relato/test_permissions.py::test_colaborador_pode_aprovar_relato PASSED [ 40%]
tests/domain/relato/test_permissions.py::test_usuario_comum_nao_pode_aprovar_relato PASSED [ 40%]
tests/domain/relato/test_permissions.py::test_admin_pode_rejeitar_relato PASSED [ 41%]
tests/domain/relato/test_permissions.py::test_colaborador_pode_rejeitar_relato PASSED [ 41%]
tests/domain/relato/test_permissions.py::test_usuario_comum_nao_pode_rejeitar_relato PASSED [ 42%]
tests/domain/relato/test_permissions.py::test_admin_pode_arquivar_relato PASSED [ 42%]
tests/domain/relato/test_permissions.py::test_colaborador_pode_arquivar_relato PASSED [ 43%]
tests/domain/relato/test_permissions.py::test_usuario_comum_nao_pode_arquivar_relato PASSED [ 44%]
tests/domain/relato/test_submit_relato.py::test_submeter_relato_estado_draft FAILED [ 44%]
tests/domain/relato/test_submit_relato.py::test_negar_submissao_estado_invalido PASSED [ 45%]
tests/domain/relato/test_submit_relato.py::test_negar_submissao_estado_processado PASSED [ 45%]
tests/domain/relato/test_submit_relato.py::test_negar_submissao_estado_error PASSED [ 46%]
tests/domain/ux_effects/test_ux_effect_public_contract.py::test_ux_effect_public_contract_snapshot FAILED [ 46%]
tests/domain/ux_effects/test_ux_effects_composition.py::test_multiple_ux_effects_preserve_order_and_contract FAILED [ 47%]
tests/domain/ux_progress/test_ux_progress.py::test_progress_with_no_effects_returns_all_steps_pending PASSED [ 48%]
tests/domain/ux_progress/test_ux_progress.py::test_persist_relato_marks_first_step_done FAILED [ 48%]
tests/domain/ux_progress/test_ux_progress.py::test_upload_images_becomes_active_when_effect_exists_but_not_completed FAILED [ 49%]
tests/domain/ux_progress/test_ux_progress.py::test_upload_images_has_more_weight_in_progress FAILED [ 49%]
tests/domain/ux_progress/test_ux_progress.py::test_error_in_any_step_sets_has_error FAILED [ 50%]
tests/domain/ux_progress/test_ux_progress.py::test_all_steps_done_marks_progress_complete FAILED [ 50%]
tests/infra/retry/test_retry_repository.py::test_load_failed_effect_results_basic 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:40 [INFO] RetryRepository | carregados=1 | limit=10
PASSED                                                                   [ 51%]
tests/infra/retry/test_retry_scheduler.py::test_retry_scheduler_runs_and_returns_decisions 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:40 [INFO] RetryScheduler | falhas encontradas=1
2026-01-27 11:57:40 [INFO] RetryScheduler | abortando retry | effect=TEST | reason=test
PASSED                                                                   [ 52%]
tests/integration/test_relato_progress_firestore.py::test_effect_result_repository_reads_from_firestore FAILED [ 52%]
tests/integration/test_relato_progress_firestore.py::test_progress_service_with_firestore_emulator PASSED [ 53%]
tests/relato/test_relato_update_status_sync.py::test_update_status_success FAILED [ 53%]
tests/relato/test_relato_update_status_sync.py::test_update_status_relato_not_found FAILED [ 54%]
tests/relato/test_relato_update_status_sync.py::test_background_error_sets_status_error FAILED [ 54%]
tests/relato/test_relato_update_status_sync.py::test_relato_state_progression FAILED [ 55%]
tests/relato/test_relato_update_status_sync.py::test_invalid_status_transition_raises FAILED [ 56%]
tests/relato/test_relato_update_status_sync.py::test_error_is_terminal FAILED [ 56%]
tests/relato/test_relatos.py::test_get_relatos_sem_autenticacao 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:54 [INFO] AUTH REJECT: Authorization header ausente.
2026-01-27 11:57:54 [INFO] GET /relatos/listar-todos 127.0.0.1 -> 401 (6.8ms) body_len=0
2026-01-27 11:57:54 [INFO] HTTP Request: GET http://test/relatos/listar-todos "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [ 57%]
tests/relato/test_relatos.py::test_get_relatos_com_autenticacao_permitida 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:54 [INFO] GET /relatos/listar-todos 127.0.0.1 -> 404 (100.3ms) body_len=0
2026-01-27 11:57:54 [INFO] HTTP Request: GET http://test/relatos/listar-todos "HTTP/1.1 404 Not Found"
FAILED                                                                   [ 57%]
tests/relato/test_relatos.py::test_get_relatos_com_autenticacao_negada 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:54 [INFO] GET /relatos/listar-todos 127.0.0.1 -> 404 (60.3ms) body_len=0
2026-01-27 11:57:54 [INFO] HTTP Request: GET http://test/relatos/listar-todos "HTTP/1.1 404 Not Found"
FAILED                                                                   [ 58%]
tests/relato/test_relatos_admin.py::test_get_relatos_com_admin 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:55 [INFO] GET /relatos/listar-todos 127.0.0.1 -> 404 (59.5ms) body_len=0
2026-01-27 11:57:55 [INFO] HTTP Request: GET http://test/relatos/listar-todos "HTTP/1.1 404 Not Found"
FAILED                                                                   [ 58%]
tests/relato/test_relatos_avancado.py::test_enviar_relato_falha_firestore_rollback 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:55 [INFO] POST /relatos/completo 127.0.0.1 -> 405 (2.5ms) body_len=1355
2026-01-27 11:57:55 [INFO] HTTP Request: POST http://test/relatos/completo "HTTP/1.1 405 Method Not Allowed"
FAILED                                                                   [ 59%]
tests/relato/test_relatos_avancado.py::test_get_my_relatos 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:55 [INFO] GET /relatos/me 127.0.0.1 -> 404 (56.3ms) body_len=0
2026-01-27 11:57:55 [INFO] HTTP Request: GET http://test/relatos/me "HTTP/1.1 404 Not Found"
FAILED                                                                   [ 60%]
tests/relato/test_relatos_avancado.py::test_get_single_relato_as_owner 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:55 [INFO] GET /relatos/relato_123 127.0.0.1 -> 404 (60.6ms) body_len=0
2026-01-27 11:57:55 [INFO] HTTP Request: GET http://test/relatos/relato_123 "HTTP/1.1 404 Not Found"
FAILED                                                                   [ 60%]
tests/relato/test_relatos_avancado.py::test_attach_image_to_relato 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:55 [INFO] POST /relatos/relato_123/attach-image 127.0.0.1 -> 404 (2.0ms) body_len=27
2026-01-27 11:57:55 [INFO] HTTP Request: POST http://test/relatos/relato_123/attach-image "HTTP/1.1 404 Not Found"
FAILED                                                                   [ 61%]
tests/relato/test_relatos_avancado.py::test_get_moderation_pending 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:55 [INFO] GET /relatos/moderation/pending 127.0.0.1 -> 404 (2.0ms) body_len=0
2026-01-27 11:57:55 [INFO] HTTP Request: GET http://test/relatos/moderation/pending "HTTP/1.1 404 Not Found"
FAILED                                                                   [ 61%]
tests/relato/test_relatos_avancado.py::test_update_relato_status 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:55 [INFO] PATCH /relatos/relato_123/status 127.0.0.1 -> 405 (1.6ms) body_len=32
2026-01-27 11:57:55 [INFO] HTTP Request: PATCH http://test/relatos/relato_123/status "HTTP/1.1 405 Method Not Allowed"
FAILED                                                                   [ 62%]
tests/relato/test_relatos_enviar.py::test_enviar_relato_sem_autenticacao 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:55 [INFO] POST /relatos/completo 127.0.0.1 -> 405 (3.0ms) body_len=3576
2026-01-27 11:57:55 [INFO] HTTP Request: POST http://test/relatos/completo "HTTP/1.1 405 Method Not Allowed"
FAILED                                                                   [ 62%]
tests/relato/test_relatos_enviar.py::test_enviar_relato_com_autenticacao 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:55 [INFO] POST /relatos/completo 127.0.0.1 -> 405 (2.1ms) body_len=3576
2026-01-27 11:57:55 [INFO] HTTP Request: POST http://test/relatos/completo "HTTP/1.1 405 Method Not Allowed"
FAILED                                                                   [ 63%]
tests/routes/test_galeria_refactor.py::test_galeria_publica_v3_route_exists 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:56 [INFO] Obtendo o bucket de armazenamento do Firebase ... $fake-bucket.appspot.com
2026-01-27 11:57:56 [INFO] Obtendo o bucket de armazenamento do Firebase ... $fake-bucket.appspot.com
2026-01-27 11:57:56 [INFO] Obtendo o bucket de armazenamento do Firebase ... $fake-bucket.appspot.com
2026-01-27 11:57:56 [INFO] GET /galeria/public/v3 127.0.0.1 -> 200 (151.2ms) body_len=0
2026-01-27 11:57:56 [INFO] HTTP Request: GET http://test/galeria/public/v3 "HTTP/1.1 200 OK"
PASSED                                                                   [ 64%]
tests/routes/test_galeria_refactor.py::test_relatos_galeria_publica_v3_route_does_not_exist 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:56 [INFO] GET /relatos/galeria/public/v3 127.0.0.1 -> 404 (2.1ms) body_len=0
2026-01-27 11:57:56 [INFO] HTTP Request: GET http://test/relatos/galeria/public/v3 "HTTP/1.1 404 Not Found"
PASSED                                                                   [ 64%]
tests/routes/test_relatos_multipart.py::test_post_relatos_with_real_multipart_upload 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:56 [INFO] POST /relatos/ testclient -> 201 (20.0ms) body_len=363
2026-01-27 11:57:56 [INFO] HTTP Request: POST http://testserver/relatos/ "HTTP/1.1 201 Created"
FAILED                                                                   [ 65%]
tests/routes/test_relatos_multipart.py::test_upload_failure_triggers_rollback FAILED [ 65%]
tests/routes/test_relatos_multipart.py::test_effect_result_persist_and_fetch_success 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:56 [INFO] Fetched EffectResult success: {'success': True, 'relato_id': 'relato-test-001', 'effect_type': 'UPLOAD_IMAGES', 'metadata': {'total_images': 2}, 'created_at': DatetimeWithNanoseconds(2026, 1, 11, 14, 26, 23, 502811, tzinfo=datetime.timezone.utc), 'error': None, 'executed_at': DatetimeWithNanoseconds(2026, 1, 11, 14, 26, 23, 502811, tzinfo=datetime.timezone.utc), 'effect_ref': 'relato-test-001'}
PASSED                                                                   [ 66%]
tests/routes/test_relatos_post.py::test_post_relatos_success FAILED      [ 66%]
tests/routes/test_relatos_post.py::test_post_relatos_denied_by_domain FAILED [ 67%]
tests/routes/test_relatos_post.py::test_post_relatos_missing_consentimento 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:56 [INFO] POST /relatos testclient -> 307 (4.2ms) body_len=169
2026-01-27 11:57:56 [INFO] HTTP Request: POST http://testserver/relatos "HTTP/1.1 307 Temporary Redirect"
2026-01-27 11:57:56 [INFO] AUTH REJECT: Authorization header ausente.
2026-01-27 11:57:56 [INFO] POST /relatos/ testclient -> 401 (12.2ms) body_len=169
2026-01-27 11:57:56 [INFO] HTTP Request: POST http://testserver/relatos/ "HTTP/1.1 401 Unauthorized"
FAILED                                                                   [ 68%]
tests/routes/test_relatos_post.py::test_post_relatos_no_consentimento_field 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:57 [INFO] POST /relatos testclient -> 307 (2.9ms) body_len=137
2026-01-27 11:57:57 [INFO] HTTP Request: POST http://testserver/relatos "HTTP/1.1 307 Temporary Redirect"
2026-01-27 11:57:57 [INFO] AUTH REJECT: Authorization header ausente.
2026-01-27 11:57:57 [INFO] POST /relatos/ testclient -> 401 (8.3ms) body_len=137
2026-01-27 11:57:57 [INFO] HTTP Request: POST http://testserver/relatos/ "HTTP/1.1 401 Unauthorized"
FAILED                                                                   [ 68%]
tests/routes/test_relatos_post.py::test_post_relatos_executor_not_called_when_denied FAILED [ 69%]
tests/routes/test_relatos_progress.py::test_get_relato_progress_unauthenticated 
-------------------------------- live log call --------------------------------
2026-01-27 11:57:57 [INFO] AUTH REJECT: Authorization header ausente.
2026-01-27 11:57:57 [INFO] GET /relatos/relato-123/progress 127.0.0.1 -> 401 (5.5ms) body_len=0
2026-01-27 11:57:57 [INFO] HTTP Request: GET http://test/relatos/relato-123/progress "HTTP/1.1 401 Unauthorized"
PASSED                                                                   [ 69%]
tests/routes/test_relatos_progress.py::test_get_relato_progress_forbidden 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:02 [INFO] GET /relatos/relato-123/progress 127.0.0.1 -> 200 (5497.5ms) body_len=0
2026-01-27 11:58:02 [INFO] HTTP Request: GET http://test/relatos/relato-123/progress "HTTP/1.1 200 OK"
FAILED                                                                   [ 70%]
tests/routes/test_relatos_progress.py::test_get_relato_progress_empty 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:08 [INFO] GET /relatos/relato-123/progress 127.0.0.1 -> 200 (6085.5ms) body_len=0
2026-01-27 11:58:08 [INFO] HTTP Request: GET http://test/relatos/relato-123/progress "HTTP/1.1 200 OK"
FAILED                                                                   [ 70%]
tests/routes/test_relatos_progress.py::test_get_relato_progress_partial_with_error 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:13 [INFO] GET /relatos/relato-123/progress 127.0.0.1 -> 200 (4782.1ms) body_len=0
2026-01-27 11:58:13 [INFO] HTTP Request: GET http://test/relatos/relato-123/progress "HTTP/1.1 200 OK"
FAILED                                                                   [ 71%]
tests/routes/test_relatos_progress.py::test_get_relato_progress_complete 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:18 [INFO] GET /relatos/relato-123/progress 127.0.0.1 -> 200 (4282.7ms) body_len=0
2026-01-27 11:58:18 [INFO] HTTP Request: GET http://test/relatos/relato-123/progress "HTTP/1.1 200 OK"
FAILED                                                                   [ 72%]
tests/services/effects/test_persist_effect_result_firestore.py::test_persist_effect_result_firestore_accepts_uuid_fields PASSED [ 72%]
tests/services/effects/test_persist_effect_result_firestore.py::test_persist_effect_result_firestore_rejects_raw_uuid_values PASSED [ 73%]
tests/services/effects/test_persist_effect_result_firestore.py::test_persist_effect_result_firestore_normalizes_uuid_before_persisting PASSED [ 73%]
tests/services/effects/test_registry_real_effects.py::test_all_effects_registered PASSED [ 74%]
tests/services/effects/test_retry_classifier.py::test_classify_timeout PASSED [ 74%]
tests/services/effects/test_retry_classifier.py::test_classify_invalid_input PASSED [ 75%]
tests/services/effects/test_retry_classifier.py::test_classify_unknown PASSED [ 76%]
tests/services/effects/test_retry_effect.py::test_retry_effect_success FAILED [ 76%]
tests/services/effects/test_retry_effect_unsupported.py::test_retry_effect_unsupported_type_raises FAILED [ 77%]
tests/services/effects/test_retry_executor.py::test_retry_persist_relato 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:18 [INFO] RetryExecutor | effect=PERSIST_RELATO | relato=relato-123 | attempt=1
FAILED                                                                   [ 77%]
tests/services/effects/test_retry_executor.py::test_retry_enqueue_processing 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:18 [INFO] RetryExecutor | effect=ENQUEUE_PROCESSING | relato=relato-456 | attempt=1
2026-01-27 11:58:18 [INFO] Executando efeitos do relato | total=1
2026-01-27 11:58:18 [INFO] Executando EnqueueProcessingEffect | relato=relato-456
PASSED                                                                   [ 78%]
tests/services/effects/test_retry_executor.py::test_retry_emit_event 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:18 [INFO] RetryExecutor | effect=EMIT_EVENT | relato=relato-789 | attempt=1
2026-01-27 11:58:18 [INFO] Executando efeitos do relato | total=1
2026-01-27 11:58:18 [WARNING] Falha na execu├º├úo de efeitos. Iniciando rollback compensat├│rio | total_executados=0
2026-01-27 11:58:18 [ERROR] RetryExecutor | falha ao reexecutar effect=EMIT_EVENT | relato=relato-789
Traceback (most recent call last):
  File "D:\workspace_projects_001\dermasync-api\app\services\relato_effect_executor.py", line 400, in execute_by_result
    self.execute([effect])
  File "D:\workspace_projects_001\dermasync-api\app\services\relato_effect_executor.py", line 70, in execute
    relato_id=effect.relato_id,
              ^^^^^^^^^^^^^^^^
AttributeError: 'EmitDomainEventEffect' object has no attribute 'relato_id'
FAILED                                                                   [ 78%]
tests/services/effects/test_retry_executor.py::test_retry_upload_images_success 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:18 [INFO] RetryExecutor | effect=UPLOAD_IMAGES | relato=relato-999 | attempt=2
FAILED                                                                   [ 79%]
tests/services/effects/test_retry_executor.py::test_retry_upload_images_without_metadata_fails 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:19 [INFO] RetryExecutor | effect=UPLOAD_IMAGES | relato=relato-000 | attempt=1
PASSED                                                                   [ 80%]
tests/services/effects/test_retry_executor.py::test_retry_unknown_effect_type_fails 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:19 [INFO] RetryExecutor | effect=UNKNOWN_EFFECT | relato=relato-err | attempt=1
PASSED                                                                   [ 80%]
tests/services/effects/test_retry_policy_contract.py::test_retry_policy_contract PASSED [ 81%]
tests/services/effects/test_retry_policy_decision.py::test_network_error_retries PASSED [ 81%]
tests/services/effects/test_retry_policy_decision.py::test_invalid_input_never_retries PASSED [ 82%]
tests/services/effects/test_retry_policy_decision.py::test_unknown_allows_single_retry PASSED [ 82%]
tests/services/readmodels/test_relato_progress_ui.py::test_progress_ui_empty FAILED [ 83%]
tests/services/readmodels/test_relato_progress_ui.py::test_progress_ui_partial_with_error FAILED [ 84%]
tests/services/readmodels/test_relato_progress_ui.py::test_progress_ui_in_progress FAILED [ 84%]
tests/services/readmodels/test_relato_progress_ui.py::test_progress_ui_completed FAILED [ 85%]
tests/services/readmodels/test_relato_progress_ui.py::test_progress_ui_with_missing_fields PASSED [ 85%]
tests/services/test_executor_idempotency.py::test_executor_skips_effect_if_already_succeeded FAILED [ 86%]
tests/services/test_ux_effects.py::test_ux_effect_contract_shape FAILED  [ 86%]
tests/services/test_ux_effects.py::test_processing_started_ux_effect_contract FAILED [ 87%]
tests/test_archlog_sync_extra.py::test_parse_logs_file_not_found 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:19 [INFO] Parsing logs from: app/archlog_sync/exemplos/nao_existe.jsonl
2026-01-27 11:58:19 [ERROR] Log file not found: app/archlog_sync/exemplos/nao_existe.jsonl
PASSED                                                                   [ 88%]
tests/test_archlog_sync_extra.py::test_parse_logs_empty 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:19 [INFO] Criando arquivo vazio para teste: C:\Users\Jefferson\AppData\Local\Temp\pytest-of-Jefferson\pytest-7\test_parse_logs_empty0\empty.jsonl
2026-01-27 11:58:19 [INFO] Parsing logs from: C:\Users\Jefferson\AppData\Local\Temp\pytest-of-Jefferson\pytest-7\test_parse_logs_empty0\empty.jsonl
PASSED                                                                   [ 88%]
tests/test_archlog_sync_extra.py::test_mermaid_empty 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:19 [INFO] Gerando diagrama de sequ├¬ncia Mermaid a partir dos eventos de log
2026-01-27 11:58:19 [INFO] Total de eventos recebidos: 0
2026-01-27 11:58:19 [WARNING] Nenhum evento fornecido, retornando diagrama vazio
PASSED                                                                   [ 89%]
tests/test_archlog_sync_extra.py::test_mermaid_order 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:19 [INFO] Testando ordem de eventos no diagrama Mermaid
2026-01-27 11:58:19 [INFO] Total de eventos no sample: 4
2026-01-27 11:58:19 [INFO] Tipo da vari├ível sample_events: <class 'list'>
2026-01-27 11:58:19 [INFO] Gerando diagrama de sequ├¬ncia Mermaid a partir dos eventos de log
2026-01-27 11:58:19 [INFO] Total de eventos recebidos: 4
PASSED                                                                   [ 89%]
tests/test_archlog_sync_extra.py::test_detect_slow_calls_edge PASSED     [ 90%]
tests/test_archlog_sync_extra.py::test_compute_avg_latency_simple PASSED [ 90%]
tests/test_healthcheck.py::test_healthz_success 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:20 [INFO] GET /healthz 127.0.0.1 -> 200 (3.0ms) body_len=0
2026-01-27 11:58:20 [INFO] HTTP Request: GET http://test/healthz "HTTP/1.1 200 OK"
PASSED                                                                   [ 91%]
tests/test_healthcheck.py::test_healthz_failure_firebase 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:20 [INFO] GET /healthz 127.0.0.1 -> 503 (0.0ms) body_len=0
2026-01-27 11:58:20 [INFO] HTTP Request: GET http://test/healthz "HTTP/1.1 503 Service Unavailable"
PASSED                                                                   [ 92%]
tests/test_healthcheck.py::test_healthz_failure_chromadb 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:20 [INFO] GET /healthz 127.0.0.1 -> 503 (3.0ms) body_len=0
2026-01-27 11:58:20 [INFO] HTTP Request: GET http://test/healthz "HTTP/1.1 503 Service Unavailable"
PASSED                                                                   [ 92%]
tests/test_imagens_avancado.py::test_upload_imagem_tipo_invalido 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:20 [INFO] Upload de imagem solicitado por user_123: invalid_file.txt
2026-01-27 11:58:20 [INFO] POST /imagens/upload 127.0.0.1 -> 415 (172.9ms) body_len=198
2026-01-27 11:58:20 [INFO] HTTP Request: POST http://test/imagens/upload "HTTP/1.1 415 Unsupported Media Type"
PASSED                                                                   [ 93%]
tests/test_imagens_avancado.py::test_upload_imagem_valido 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:20 [INFO] Upload de imagem solicitado por user_123: valid_image.jpeg
2026-01-27 11:58:20 [INFO] POST /imagens/upload 127.0.0.1 -> 200 (7.8ms) body_len=811
2026-01-27 11:58:20 [INFO] HTTP Request: POST http://test/imagens/upload "HTTP/1.1 200 OK"
PASSED                                                                   [ 93%]
tests/test_imagens_avancado.py::test_get_imagem_signed_url 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:20 [INFO] GET /imagens/image_123 127.0.0.1 -> 404 (0.0ms) body_len=0
2026-01-27 11:58:20 [INFO] HTTP Request: GET http://test/imagens/image_123 "HTTP/1.1 404 Not Found"
FAILED                                                                   [ 94%]
tests/test_parser_metrics.py::test_parse_logs_groups 
------------------------------- live log setup --------------------------------
2026-01-27 11:58:20 [INFO] Parsing logs from: app/archlog_sync/exemplos/relato_log.jsonl
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:01Z', 'request_id': 'req_001', 'caller': 'frontend', 'callee': 'relato_service', 'operation': 'POST /enviar-relato', 'status_code': 200, 'duration_ms': 122}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:02Z', 'request_id': 'req_001', 'caller': 'relato_service', 'callee': 'firebase_storage', 'operation': 'upload_imagem', 'status_code': 200, 'duration_ms': 321}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:03Z', 'request_id': 'req_001', 'caller': 'relato_service', 'callee': 'llm_extractor', 'operation': 'extrair_tags', 'status_code': 200, 'duration_ms': 1522}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:04Z', 'request_id': 'req_001', 'caller': 'llm_extractor', 'callee': 'chromadb', 'operation': 'persistir_vetor', 'status_code': 200, 'duration_ms': 88}
2026-01-27 11:58:20 [INFO] Loaded groups: {"req_001": [{"timestamp": "2025-07-04T14:00:01Z", "request_id": "req_001", "caller": "frontend", "callee": "relato_service", "operation": "POST /enviar-relato", "status_code": 200, "duration_ms": 122}, {"timestamp": "2025-07-04T14:00:02Z", "request_id": "req_001", "caller": "relato_service", "callee": "firebase_storage", "operation": "upload_imagem", "status_code": 200, "duration_ms": 321}, {"timestamp": "2025-07-04T14:00:03Z", "request_id": "req_001", "caller": "relato_service", "callee": "llm_extractor", "operation": "extrair_tags", "status_code": 200, "duration_ms": 1522}, {"timestamp": "2025-07-04T14:00:04Z", "request_id": "req_001", "caller": "llm_extractor", "callee": "chromadb", "operation": "persistir_vetor", "status_code": 200, "duration_ms": 88}]}
PASSED                                                                   [ 94%]
tests/test_parser_metrics.py::test_mermaid_generator 
------------------------------- live log setup --------------------------------
2026-01-27 11:58:20 [INFO] Parsing logs from: app/archlog_sync/exemplos/relato_log.jsonl
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:01Z', 'request_id': 'req_001', 'caller': 'frontend', 'callee': 'relato_service', 'operation': 'POST /enviar-relato', 'status_code': 200, 'duration_ms': 122}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:02Z', 'request_id': 'req_001', 'caller': 'relato_service', 'callee': 'firebase_storage', 'operation': 'upload_imagem', 'status_code': 200, 'duration_ms': 321}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:03Z', 'request_id': 'req_001', 'caller': 'relato_service', 'callee': 'llm_extractor', 'operation': 'extrair_tags', 'status_code': 200, 'duration_ms': 1522}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:04Z', 'request_id': 'req_001', 'caller': 'llm_extractor', 'callee': 'chromadb', 'operation': 'persistir_vetor', 'status_code': 200, 'duration_ms': 88}
2026-01-27 11:58:20 [INFO] Loaded groups: {"req_001": [{"timestamp": "2025-07-04T14:00:01Z", "request_id": "req_001", "caller": "frontend", "callee": "relato_service", "operation": "POST /enviar-relato", "status_code": 200, "duration_ms": 122}, {"timestamp": "2025-07-04T14:00:02Z", "request_id": "req_001", "caller": "relato_service", "callee": "firebase_storage", "operation": "upload_imagem", "status_code": 200, "duration_ms": 321}, {"timestamp": "2025-07-04T14:00:03Z", "request_id": "req_001", "caller": "relato_service", "callee": "llm_extractor", "operation": "extrair_tags", "status_code": 200, "duration_ms": 1522}, {"timestamp": "2025-07-04T14:00:04Z", "request_id": "req_001", "caller": "llm_extractor", "callee": "chromadb", "operation": "persistir_vetor", "status_code": 200, "duration_ms": 88}]}
-------------------------------- live log call --------------------------------
2026-01-27 11:58:20 [INFO] Gerando diagrama de sequ├¬ncia Mermaid a partir dos eventos de log
2026-01-27 11:58:20 [INFO] Total de eventos recebidos: 4
PASSED                                                                   [ 95%]
tests/test_parser_metrics.py::test_compute_avg_latency 
------------------------------- live log setup --------------------------------
2026-01-27 11:58:20 [INFO] Parsing logs from: app/archlog_sync/exemplos/relato_log.jsonl
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:01Z', 'request_id': 'req_001', 'caller': 'frontend', 'callee': 'relato_service', 'operation': 'POST /enviar-relato', 'status_code': 200, 'duration_ms': 122}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:02Z', 'request_id': 'req_001', 'caller': 'relato_service', 'callee': 'firebase_storage', 'operation': 'upload_imagem', 'status_code': 200, 'duration_ms': 321}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:03Z', 'request_id': 'req_001', 'caller': 'relato_service', 'callee': 'llm_extractor', 'operation': 'extrair_tags', 'status_code': 200, 'duration_ms': 1522}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:04Z', 'request_id': 'req_001', 'caller': 'llm_extractor', 'callee': 'chromadb', 'operation': 'persistir_vetor', 'status_code': 200, 'duration_ms': 88}
2026-01-27 11:58:20 [INFO] Loaded groups: {"req_001": [{"timestamp": "2025-07-04T14:00:01Z", "request_id": "req_001", "caller": "frontend", "callee": "relato_service", "operation": "POST /enviar-relato", "status_code": 200, "duration_ms": 122}, {"timestamp": "2025-07-04T14:00:02Z", "request_id": "req_001", "caller": "relato_service", "callee": "firebase_storage", "operation": "upload_imagem", "status_code": 200, "duration_ms": 321}, {"timestamp": "2025-07-04T14:00:03Z", "request_id": "req_001", "caller": "relato_service", "callee": "llm_extractor", "operation": "extrair_tags", "status_code": 200, "duration_ms": 1522}, {"timestamp": "2025-07-04T14:00:04Z", "request_id": "req_001", "caller": "llm_extractor", "callee": "chromadb", "operation": "persistir_vetor", "status_code": 200, "duration_ms": 88}]}
PASSED                                                                   [ 96%]
tests/test_parser_metrics.py::test_detect_slow_calls 
------------------------------- live log setup --------------------------------
2026-01-27 11:58:20 [INFO] Parsing logs from: app/archlog_sync/exemplos/relato_log.jsonl
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:01Z', 'request_id': 'req_001', 'caller': 'frontend', 'callee': 'relato_service', 'operation': 'POST /enviar-relato', 'status_code': 200, 'duration_ms': 122}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:02Z', 'request_id': 'req_001', 'caller': 'relato_service', 'callee': 'firebase_storage', 'operation': 'upload_imagem', 'status_code': 200, 'duration_ms': 321}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:03Z', 'request_id': 'req_001', 'caller': 'relato_service', 'callee': 'llm_extractor', 'operation': 'extrair_tags', 'status_code': 200, 'duration_ms': 1522}
2026-01-27 11:58:20 [INFO] Processing entry: {'timestamp': '2025-07-04T14:00:04Z', 'request_id': 'req_001', 'caller': 'llm_extractor', 'callee': 'chromadb', 'operation': 'persistir_vetor', 'status_code': 200, 'duration_ms': 88}
2026-01-27 11:58:20 [INFO] Loaded groups: {"req_001": [{"timestamp": "2025-07-04T14:00:01Z", "request_id": "req_001", "caller": "frontend", "callee": "relato_service", "operation": "POST /enviar-relato", "status_code": 200, "duration_ms": 122}, {"timestamp": "2025-07-04T14:00:02Z", "request_id": "req_001", "caller": "relato_service", "callee": "firebase_storage", "operation": "upload_imagem", "status_code": 200, "duration_ms": 321}, {"timestamp": "2025-07-04T14:00:03Z", "request_id": "req_001", "caller": "relato_service", "callee": "llm_extractor", "operation": "extrair_tags", "status_code": 200, "duration_ms": 1522}, {"timestamp": "2025-07-04T14:00:04Z", "request_id": "req_001", "caller": "llm_extractor", "callee": "chromadb", "operation": "persistir_vetor", "status_code": 200, "duration_ms": 88}]}
PASSED                                                                   [ 96%]
tests/test_pipeline_01_jsonlbruto.py::test_gerar_jsonl_bruto_formato_valido 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:20 [INFO] Iniciando a gera├º├úo do JSONL bruto...
2026-01-27 11:58:20 [INFO] Par├ómetros de entrada: {'origem': 'facebook', 'src_dir': 'C:\\Users\\JEFFER~1\\AppData\\Local\\Temp\\tmpzmqcuhb3', 'ctx_id': '1234567890', 'grupo': 'Dermatite At├│pica Brasil', 'tipo': 'comentario'}, C:\Users\JEFFER~1\AppData\Local\Temp\tmpzmqcuhb3\saida.jsonl
2026-01-27 11:58:20 [INFO] Dado gerado: {'id_relato': '5100ea01cb494faaa1cde2a7de9ad2b8', 'origem': {'plataforma': 'facebook', 'link': None, 'tipo': 'comentario', 'ano_postagem': None, 'grupo': 'Dermatite At├│pica Brasil', 'ctx_id': '1234567890'}, 'versao_pipeline': 'v0.0.1', 'data_modificacao': '2026-01-27T11:58:20.692707', 'conteudo_original': 'Relato de teste sobre coceira e pele seca.'}
PASSED                                                                   [ 97%]
tests/test_pipeline_01_jsonlbruto.py::test_valida_schema_jsonl_bruto PASSED [ 97%]
tests/test_pipeline_02_enriquecer_metadados.py::test_enriquecer_metadados_formato_valido 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:27 [INFO] Usando cliente LLM: <app.pipeline.llm_client.gemini_client.GeminiClient object at 0x0000023FAD235E10>
2026-01-27 11:58:27 [INFO] Enviando prompt para LLM...
2026-01-27 11:58:27 [ERROR] Erro ao processar relato: 404 models/gemini is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.
FAILED                                                                   [ 98%]
tests/test_pipeline_02_enriquecer_metadados.py::test_if_jsonl_linha_valido PASSED [ 98%]
tests/test_pipeline_integracao_01_02.py::test_integracao_fase_01_e_02 
-------------------------------- live log call --------------------------------
2026-01-27 11:58:28 [INFO] Iniciando a gera├º├úo do JSONL bruto...
2026-01-27 11:58:28 [INFO] Par├ómetros de entrada: {'origem': 'facebook', 'src_dir': 'C:\\Users\\JEFFER~1\\AppData\\Local\\Temp\\tmpbv4u9b4c', 'ctx_id': 'CTX1234567890', 'grupo': 'Grupo de Teste', 'tipo': 'comentario'}, C:\Users\JEFFER~1\AppData\Local\Temp\tmpbv4u9b4c\saida.jsonl
2026-01-27 11:58:28 [INFO] Usando cliente LLM: <app.pipeline.llm_client.gemini_client.GeminiClient object at 0x0000023FAE7639D0>
2026-01-27 11:58:28 [INFO] Enviando prompt para LLM...
2026-01-27 11:58:28 [ERROR] Erro ao processar relato: 404 models/gemini is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.
FAILED                                                                   [ 99%]
tests/ux/test_cognitive_integration_flow.py::test_user_sees_coherent_story_from_ux_effects FAILED [100%]

================================== FAILURES ===================================
_____________ test_job_persists_snapshot_when_progress_is_stable ______________

    def test_job_persists_snapshot_when_progress_is_stable():
        snapshot_repo = Mock()
        effect_repo = Mock()
    
        snapshot_repo.get_by_relato_id.return_value = None
    
        effect_repo.fetch_by_relato_id.return_value = [
>           EffectResult(
                type="PERSIST_RELATO",
                success=True,
                executed_at=datetime.utcnow(),
            ),
            EffectResult(
                type="UPLOAD_IMAGES",
                success=True,
                executed_at=datetime.utcnow(),
            ),
            EffectResult(
                type="ENRICH_METADATA",
                success=True,
                executed_at=datetime.utcnow(),
            ),
        ]
E       TypeError: EffectResult.__init__() missing 2 required positional arguments: 'error_message' and 'metadata'

tests\application\test_relato_progress_stabilization_service.py:35: TypeError
____________________ test_retry_endpoint_returns_ux_effect ____________________

client = <httpx.AsyncClient object at 0x0000023FAD158A50>

    @pytest.mark.asyncio
    async def test_retry_endpoint_returns_ux_effect(client):
        response = await client.post("/relatos/relato-123/retry")
        body = response.json()
    
        assert "ux_effects" in body
>       assert body["ux_effects"][0]["type"] == "RetryUXEffect"
               ^^^^^^^^^^^^^^^^^^^^^
E       IndexError: list index out of range

tests\domain\effects\test_retry_ux_effects.py:92: IndexError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:37,698", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:37,826", "level": "INFO", "logger": "app.services.effects.fetch_firestore", "message": "Fetched 6 failed EffectResults for relato=relato-123"}
{"timestamp": "2026-01-27 11:57:37,827", "level": "DEBUG", "logger": "app.services.ux_adapters", "message": "Ignoring non-UX domain effect: RetryUXEffect"}
{"timestamp": "2026-01-27 11:57:37,829", "level": "INFO", "logger": "root", "message": "POST /relatos/relato-123/retry 127.0.0.1 -> 202 (100.9ms) body_len=0"}
{"timestamp": "2026-01-27 11:57:37,830", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://test/relatos/relato-123/retry \"HTTP/1.1 202 Accepted\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:37] [INFO] [request_logger] POST /relatos/relato-123/retry Status: 202 Tempo: 99.78ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:37 [INFO] Fetched 6 failed EffectResults for relato=relato-123
2026-01-27 11:57:37 [INFO] POST /relatos/relato-123/retry 127.0.0.1 -> 202 (100.9ms) body_len=0
2026-01-27 11:57:37 [INFO] HTTP Request: POST http://test/relatos/relato-123/retry "HTTP/1.1 202 Accepted"
____________________ test_valid_payload_passes_validation _____________________

    def test_valid_payload_passes_validation():
        model = EnrichedMetadataV2.model_validate(VALID_PAYLOAD)
        assert model.version == "v2"
>       assert model.confidence.extraction == 0.85
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'extraction'

tests\domain\enrichment\test_enriched_metadata_v2_validator.py:39: AttributeError
___________________________ test_extra_field_fails ____________________________

    def test_extra_field_fails():
        payload = VALID_PAYLOAD | {"unexpected": "boom"}
    
>       with pytest.raises(Exception):
E       Failed: DID NOT RAISE <class 'Exception'>

tests\domain\enrichment\test_enriched_metadata_v2_validator.py:44: Failed
______________________ test_criar_relato_estado_inicial _______________________

    def test_criar_relato_estado_inicial():
        """Testa a cria├º├úo de um relato quando n├úo existe estado anterior."""
        actor = Actor(id="user-123", role=ActorRole.USER)
>       command = CreateRelato(
            relato_id="relato-456",
            owner_id="user-123",
            conteudo="Relato de teste",
            imagens={"antes": [], "durante": [], "depois": []}
        )
E       TypeError: CreateRelato.__init__() got an unexpected keyword argument 'imagens'

tests\domain\relato\test_create_relato.py:19: TypeError
_____________________ test_negar_criacao_relato_existente _____________________

    def test_negar_criacao_relato_existente():
        """Testa que n├úo ├® poss├¡vel criar um relato se ele j├í existe (estado n├úo ├® None)."""
        actor = Actor(id="user-123", role=ActorRole.USER)
>       command = CreateRelato(
            relato_id="relato-456",
            owner_id="user-123",
            conteudo="Relato de teste",
            imagens={"antes": [], "durante": [], "depois": []}
        )
E       TypeError: CreateRelato.__init__() got an unexpected keyword argument 'imagens'

tests\domain\relato\test_create_relato.py:38: TypeError
_________ test_post_relatos_success_runs_domain_and_executes_effects __________

    def test_post_relatos_success_runs_domain_and_executes_effects():
        from app.main import app
        from app.auth.schemas import User
        from app.auth.dependencies import get_current_user
        from fastapi.testclient import TestClient
        from unittest.mock import MagicMock, patch
        import json
    
        mock_user = User(
            id="user-123",
            email="test@example.com",
            role="usuario_logado"
        )
    
        # ­ƒöæ override correto do Depends
        app.dependency_overrides[get_current_user] = lambda: mock_user
    
        client = TestClient(app)
    
        # Ô£à payload MINIMAMENTE v├ílido segundo RelatoDraftInput
        payload = {
            "descricao": "Relato v├ílido",
            "consentimento": True,
            "idade": 35
        }
    
        try:
            with patch(
                "app.routes.relatos.RelatoEffectExecutor"
            ) as mock_executor_class:
                mock_executor_instance = MagicMock()
                mock_executor_class.return_value = mock_executor_instance
    
                response = client.post(
                    "/relatos/",
                    data={"payload": json.dumps(payload)}
                )
    
                assert response.status_code == 201
    
                body = response.json()
>               assert "relato_id" in body
E               AssertionError: assert 'relato_id' in {'data': {'relato_id': 'dbe7f806733c4170b13be2adc53cafe7', 'status': 'created'}, 'ux_effects': [{'channel': 'progress', 'message': 'Relato recebido e salvo.', 'relato_id': 'dbe7f806733c4170b13be2adc53cafe7', 'severity': 'info', ...}, {'channel': 'progress', 'message': 'Imagens enviadas para processamento.', 'relato_id': 'dbe7f806733c4170b13be2adc53cafe7', 'severity': 'info', ...}]}

tests\domain\relato\test_create_relato.py:95: AssertionError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:38,225", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
{"timestamp": "2026-01-27 11:57:38,255", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_start with no data"}
{"timestamp": "2026-01-27 11:57:38,256", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_name with data[0:7]"}
{"timestamp": "2026-01-27 11:57:38,257", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_data with data[8:111]"}
{"timestamp": "2026-01-27 11:57:38,258", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_end with no data"}
{"timestamp": "2026-01-27 11:57:38,258", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_end with no data"}
{"timestamp": "2026-01-27 11:57:38,270", "level": "INFO", "logger": "root", "message": "POST /relatos/ testclient -> 201 (21.0ms) body_len=111"}
{"timestamp": "2026-01-27 11:57:38,277", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://testserver/relatos/ \"HTTP/1.1 201 Created\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:38] [INFO] [request_logger] POST /relatos/ Status: 201 Tempo: 17.19ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:38 [INFO] POST /relatos/ testclient -> 201 (21.0ms) body_len=111
2026-01-27 11:57:38 [INFO] HTTP Request: POST http://testserver/relatos/ "HTTP/1.1 201 Created"
___________________ test_create_relato_emits_typed_effects ____________________

    def test_create_relato_emits_typed_effects():
        actor = Actor(id="user-123", role=ActorRole.USER)
    
>       command = CreateRelato(
            relato_id="relato-1",
            owner_id="user-123",
            conteudo="Relato v├ílido",
            imagens={"antes": [], "durante": [], "depois": []},
        )
E       TypeError: CreateRelato.__init__() got an unexpected keyword argument 'imagens'

tests\domain\relato\test_create_relato.py:187: TypeError
_________________ test_create_relato_initial_state_is_created _________________

    def test_create_relato_initial_state_is_created():
        decision = decide(
>           command=CreateRelato(
            relato_id="relato-1",
            owner_id="user-123",
            conteudo="Relato v├ílido",
            imagens={"antes": [], "durante": [], "depois": []},
        ),
            actor=Actor(id="user-123", role=ActorRole.USER),
            current_state=None
        )
E       TypeError: CreateRelato.__init__() got an unexpected keyword argument 'imagens'

tests\domain\relato\test_create_relato.py:207: TypeError
________________ test_create_relato_allowed_from_initial_state ________________

    def test_create_relato_allowed_from_initial_state():
        """Testa que a cria├º├úo de relato ├® permitida a partir do estado inicial (None)."""
        actor = Actor(id="user-123", role=ActorRole.USER)
>       command = CreateRelato(
            relato_id="relato-456",
            owner_id="user-123",
            conteudo="Relato de teste",
            imagens={"antes": [], "durante": [], "depois": []}
        )
E       TypeError: CreateRelato.__init__() got an unexpected keyword argument 'imagens'

tests\domain\relato\test_create_relato_decision.py:19: TypeError
________________ test_create_relato_denied_when_already_exists ________________

    def test_create_relato_denied_when_already_exists():
        """Testa que a cria├º├úo de relato ├® negada quando o relato j├í existe (estado n├úo ├® None)."""
        actor = Actor(id="user-123", role=ActorRole.USER)
>       command = CreateRelato(
            relato_id="relato-456",
            owner_id="user-123",
            conteudo="Relato de teste",
            imagens={"antes": [], "durante": [], "depois": []}
        )
E       TypeError: CreateRelato.__init__() got an unexpected keyword argument 'imagens'

tests\domain\relato\test_create_relato_decision.py:38: TypeError
______________ test_create_relato_denied_from_any_existing_state ______________

    def test_create_relato_denied_from_any_existing_state():
        """Testa que a cria├º├úo de relato ├® negada a partir de qualquer estado existente."""
        actor = Actor(id="user-123", role=ActorRole.USER)
>       command = CreateRelato(
            relato_id="relato-456",
            owner_id="user-123",
            conteudo="Relato de teste",
            imagens={"antes": [], "durante": [], "depois": []}
        )
E       TypeError: CreateRelato.__init__() got an unexpected keyword argument 'imagens'

tests\domain\relato\test_create_relato_decision.py:58: TypeError
____________________ test_create_relato_effects_structure _____________________

    def test_create_relato_effects_structure():
        """Testa que a decis├úo de cria├º├úo retorna efeitos com a estrutura esperada."""
        actor = Actor(id="user-123", role=ActorRole.USER)
>       command = CreateRelato(
            relato_id="relato-456",
            owner_id="user-123",
            conteudo="Relato de teste",
            imagens={"antes": [{"filename": "img.jpg", "content": b"...", "content_type": "image/jpeg"}],
                     "durante": [], "depois": []}
        )
E       TypeError: CreateRelato.__init__() got an unexpected keyword argument 'imagens'

tests\domain\relato\test_create_relato_decision.py:81: TypeError
______________________ test_negar_aprovacao_estado_draft ______________________

    def test_negar_aprovacao_estado_draft():
        """N├úo ├® poss├¡vel aprovar um relato em estado DRAFT."""
        actor = Actor(id="admin-123", role=ActorRole.ADMIN)
        command = ApproveRelatoPublic(relato_id="relato-456")
    
        decision = decide(
            command=command,
            actor=actor,
>           current_state=RelatoStatus.DRAFT,
                          ^^^^^^^^^^^^^^^^^^
        )

tests\domain\relato\test_invalid_transitions.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <enum 'RelatoStatus'>, name = 'DRAFT'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
>           raise AttributeError(name) from None
E           AttributeError: DRAFT

C:\Python311\Lib\enum.py:783: AttributeError
______________________ test_negar_rejeicao_estado_draft _______________________

    def test_negar_rejeicao_estado_draft():
        """N├úo ├® poss├¡vel rejeitar um relato em estado DRAFT."""
        actor = Actor(id="admin-123", role=ActorRole.ADMIN)
        command = RejectRelato(relato_id="relato-456")
    
        decision = decide(
            command=command,
            actor=actor,
>           current_state=RelatoStatus.DRAFT,
                          ^^^^^^^^^^^^^^^^^^
        )

tests\domain\relato\test_invalid_transitions.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <enum 'RelatoStatus'>, name = 'DRAFT'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
>           raise AttributeError(name) from None
E           AttributeError: DRAFT

C:\Python311\Lib\enum.py:783: AttributeError
_______________ test_negar_marcar_como_processado_estado_draft ________________

    def test_negar_marcar_como_processado_estado_draft():
        """N├úo ├® poss├¡vel marcar um relato como processado a partir de DRAFT."""
        actor = Actor(id="system", role=ActorRole.SYSTEM)
        command = MarkRelatoAsProcessed(relato_id="relato-456")
    
        decision = decide(
            command=command,
            actor=actor,
>           current_state=RelatoStatus.DRAFT,
                          ^^^^^^^^^^^^^^^^^^
        )

tests\domain\relato\test_invalid_transitions.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <enum 'RelatoStatus'>, name = 'DRAFT'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
>           raise AttributeError(name) from None
E           AttributeError: DRAFT

C:\Python311\Lib\enum.py:783: AttributeError
______________________ test_submeter_relato_estado_draft ______________________

    def test_submeter_relato_estado_draft():
        """Testa a submiss├úo de um relato a partir do estado DRAFT."""
        actor = Actor(id="user-123", role=ActorRole.USER)
        command = SubmitRelato(relato_id="relato-456")
    
>       decision = decide(command=command, actor=actor, current_state=RelatoStatus.DRAFT)
                                                                      ^^^^^^^^^^^^^^^^^^

tests\domain\relato\test_submit_relato.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <enum 'RelatoStatus'>, name = 'DRAFT'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
>           raise AttributeError(name) from None
E           AttributeError: DRAFT

C:\Python311\Lib\enum.py:783: AttributeError
___________________ test_ux_effect_public_contract_snapshot ___________________

    def test_ux_effect_public_contract_snapshot():
        """
        Este teste protege o CONTRATO P├ÜBLICO de UX Effects.
        Qualquer altera├º├úo aqui ├® BREAKING CHANGE.
        """
    
        effect = ProcessingStartedUXEffect.default(
            relato_id="relato_123"
        )
    
        payload = serialize_ux_effects([effect])
    
        # Garantia 1: serializ├ível em JSON puro
        json.dumps(payload)
    
        # Garantia 2: shape p├║blico est├ível
>       assert payload == {
            "ux_effects": [
                {
                    "type": "processing_started",
                    "severity": "info",
                    "channel": "banner",
                    "timing": "after_processing",
                    "message": "Seu relato est├í sendo processado. Isso pode levar alguns instantes.",
                }
            ]
        }
E       AssertionError: assert [] == {'ux_effects'...ssing', ...}]}
E         
E         Full diff:
E         + []
E         - {
E         -     'ux_effects': [
E         -         {
E         -             'channel': 'banner',...
E         
E         ...Full output truncated (8 lines hidden), use '-vv' to show

tests\domain\ux_effects\test_ux_effect_public_contract.py:24: AssertionError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:40,166", "level": "DEBUG", "logger": "app.services.ux_adapters", "message": "Ignoring non-UX domain effect: ProcessingStartedUXEffect"}
____________ test_multiple_ux_effects_preserve_order_and_contract _____________

    def test_multiple_ux_effects_preserve_order_and_contract():
        effects = [
            ProcessingStartedUXEffect.default(relato_id="relato_123"),
            RetryUXEffect.retrying(
                relato_id="relato_123",
                count=2,
            ),
        ]
    
        payload = serialize_ux_effects(effects)
    
        json.dumps(payload)
    
>       assert payload == {
            "ux_effects": [
                {
                    "type": "processing_started",
                    "severity": "info",
                    "channel": "banner",
                    "timing": "after_processing",
                    "message": "Seu relato est├í sendo processado. Isso pode levar alguns instantes.",
                },
                {
                    "type": "retrying",
                    "severity": "info",
                    "channel": "banner",
                    "timing": "immediate",
                    "message": "2 a├º├Áes est├úo sendo repetidas.",
                },
            ]
        }
E       AssertionError: assert [] == {'ux_effects'...diate', ...}]}
E         
E         Full diff:
E         + []
E         - {
E         -     'ux_effects': [
E         -         {
E         -             'channel': 'banner',...
E         
E         ...Full output truncated (15 lines hidden), use '-vv' to show

tests\domain\ux_effects\test_ux_effects_composition.py:22: AssertionError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:40,210", "level": "DEBUG", "logger": "app.services.ux_adapters", "message": "Ignoring non-UX domain effect: ProcessingStartedUXEffect"}
{"timestamp": "2026-01-27 11:57:40,210", "level": "DEBUG", "logger": "app.services.ux_adapters", "message": "Ignoring non-UX domain effect: RetryUXEffect"}
__________________ test_persist_relato_marks_first_step_done __________________

    def test_persist_relato_marks_first_step_done():
        steps = default_step_definitions()
    
        effects = [
            EffectResult(
                type="PERSIST_RELATO",
                success=True,
>               executed_at=dt("2026-01-17T10:00:00")
                            ^^
            )
        ]
E       NameError: name 'dt' is not defined

tests\domain\ux_progress\test_ux_progress.py:31: NameError
___ test_upload_images_becomes_active_when_effect_exists_but_not_completed ____

    def test_upload_images_becomes_active_when_effect_exists_but_not_completed():
        steps = default_step_definitions()
    
        effects = [
>           EffectResult(type="PERSIST_RELATO", success=True),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            EffectResult(type="UPLOAD_IMAGES", success=False)
        ]
E       TypeError: EffectResult.__init__() got an unexpected keyword argument 'type'

tests\domain\ux_progress\test_ux_progress.py:47: TypeError
_______________ test_upload_images_has_more_weight_in_progress ________________

    def test_upload_images_has_more_weight_in_progress():
        steps = default_step_definitions()
    
        effects = [
>           EffectResult(type="PERSIST_RELATO", success=True),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            EffectResult(type="UPLOAD_IMAGES", success=True),
        ]
E       TypeError: EffectResult.__init__() got an unexpected keyword argument 'type'

tests\domain\ux_progress\test_ux_progress.py:62: TypeError
____________________ test_error_in_any_step_sets_has_error ____________________

    def test_error_in_any_step_sets_has_error():
        steps = default_step_definitions()
    
        effects = [
>           EffectResult(type="PERSIST_RELATO", success=True),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            EffectResult(type="UPLOAD_IMAGES", success=False),
        ]
E       TypeError: EffectResult.__init__() got an unexpected keyword argument 'type'

tests\domain\ux_progress\test_ux_progress.py:74: TypeError
_________________ test_all_steps_done_marks_progress_complete _________________

    def test_all_steps_done_marks_progress_complete():
        steps = default_step_definitions()
    
        effects = [
>           EffectResult(type="PERSIST_RELATO", success=True),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            EffectResult(type="UPLOAD_IMAGES", success=True),
            EffectResult(type="ENRICH_METADATA", success=True),
        ]
E       TypeError: EffectResult.__init__() got an unexpected keyword argument 'type'

tests\domain\ux_progress\test_ux_progress.py:87: TypeError
_____________ test_effect_result_repository_reads_from_firestore ______________

    def test_effect_result_repository_reads_from_firestore():
        client = firestore.Client()
        repo = EffectResultRepository(firestore_client=client)
    
        relato_id = "relato_integration_1"
    
        client.collection("effect_results").add({
            "relato_id": relato_id,
            "effect_type": "PERSIST_RELATO",
            "success": True,
            "executed_at": datetime.utcnow(),
            "error": None,
        })
    
        results = repo.fetch_by_relato_id(relato_id)
    
>       assert len(results) == 1
E       AssertionError: assert 9 == 1
E        +  where 9 = len([EffectResult(type='PERSIST_RELATO', success=True, executed_at=DatetimeWithNanoseconds(2026, 1, 23, 9, 1, 12, 819992, tzinfo=datetime.timezone.utc), error_message=None, metadata=None), EffectResult(type='PERSIST_RELATO', success=True, executed_at=DatetimeWithNanoseconds(2026, 1, 24, 17, 30, 17, 804956, tzinfo=datetime.timezone.utc), error_message=None, metadata=None), EffectResult(type='PERSIST_RELATO', success=True, executed_at=DatetimeWithNanoseconds(2026, 1, 26, 18, 31, 43, 809187, tzinfo=datetime.timezone.utc), error_message=None, metadata=None), EffectResult(type='PERSIST_RELATO', success=True, executed_at=DatetimeWithNanoseconds(2026, 1, 26, 18, 47, 49, 61347, tzinfo=datetime.timezone.utc), error_message=None, metadata=None), EffectResult(type='PERSIST_RELATO', success=True, executed_at=DatetimeWithNanoseconds(2026, 1, 26, 21, 47, 35, 450343, tzinfo=datetime.timezone.utc), error_message=None, metadata=None), EffectResult(type='PERSIST_RELATO', success=True, executed_at=DatetimeWithNanoseconds(2026, 1, 26, 21, 54, 58, 894728, tzinfo=datetime.timezone.utc), error_message=None, metadata=None), ...])

tests\integration\test_relato_progress_firestore.py:24: AssertionError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:47,607", "level": "DEBUG", "logger": "urllib3.connectionpool", "message": "Starting new HTTPS connection (1): oauth2.googleapis.com:443"}
{"timestamp": "2026-01-27 11:57:47,842", "level": "DEBUG", "logger": "urllib3.connectionpool", "message": "https://oauth2.googleapis.com:443 \"POST /token HTTP/1.1\" 200 None"}
_________________________ test_update_status_success __________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD24EAD0>
mock_firestore = <MagicMock id='2472510163088'>

    def test_update_status_success(monkeypatch, mock_firestore):
>       from app.services.relatos_background import update_relato_status_sync
E       ImportError: cannot import name 'update_relato_status_sync' from 'app.services.relatos_background' (D:\workspace_projects_001\dermasync-api\app\services\relatos_background.py)

tests\relato\test_relato_update_status_sync.py:6: ImportError
_____________________ test_update_status_relato_not_found _____________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD285A10>
mock_firestore = <MagicMock id='2472511298832'>

    def test_update_status_relato_not_found(monkeypatch, mock_firestore):
>       from app.services.relatos_background import update_relato_status_sync
E       ImportError: cannot import name 'update_relato_status_sync' from 'app.services.relatos_background' (D:\workspace_projects_001\dermasync-api\app\services\relatos_background.py)

tests\relato\test_relato_update_status_sync.py:30: ImportError
___________________ test_background_error_sets_status_error ___________________

obj = <module 'app.services.relatos_background' from 'D:\\workspace_projects_001\\dermasync-api\\app\\services\\relatos_background.py'>
name = 'salvar_imagem_bytes_to_storage', ann = 'app.services.relatos_background'

    def annotated_getattr(obj: object, name: str, ann: str) -> object:
        try:
>           obj = getattr(obj, name)
                  ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'app.services.relatos_background' has no attribute 'salvar_imagem_bytes_to_storage'

venv\Lib\site-packages\_pytest\monkeypatch.py:90: AttributeError

The above exception was the direct cause of the following exception:

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD277090>
mock_firestore = <MagicMock id='2472511444944'>

    def test_background_error_sets_status_error(monkeypatch, mock_firestore):
        from app.services.relatos_background import _save_files_and_enqueue
    
        def fake_save(*args, **kwargs):
            raise ValueError("boom")
    
>       monkeypatch.setattr(
            "app.services.relatos_background.salvar_imagem_bytes_to_storage",
            fake_save
        )

tests\relato\test_relato_update_status_sync.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\_pytest\monkeypatch.py:104: in derive_importpath
    annotated_getattr(target, attr, ann=module)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

obj = <module 'app.services.relatos_background' from 'D:\\workspace_projects_001\\dermasync-api\\app\\services\\relatos_background.py'>
name = 'salvar_imagem_bytes_to_storage', ann = 'app.services.relatos_background'

    def annotated_getattr(obj: object, name: str, ann: str) -> object:
        try:
            obj = getattr(obj, name)
        except AttributeError as e:
>           raise AttributeError(
                f"{type(obj).__name__!r} object at {ann} has no attribute {name!r}"
            ) from e
E           AttributeError: 'module' object at app.services.relatos_background has no attribute 'salvar_imagem_bytes_to_storage'

venv\Lib\site-packages\_pytest\monkeypatch.py:92: AttributeError
________________________ test_relato_state_progression ________________________

obj = <module 'app.services.relatos_background' from 'D:\\workspace_projects_001\\dermasync-api\\app\\services\\relatos_background.py'>
name = 'salvar_imagem_bytes_to_storage', ann = 'app.services.relatos_background'

    def annotated_getattr(obj: object, name: str, ann: str) -> object:
        try:
>           obj = getattr(obj, name)
                  ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'app.services.relatos_background' has no attribute 'salvar_imagem_bytes_to_storage'

venv\Lib\site-packages\_pytest\monkeypatch.py:90: AttributeError

The above exception was the direct cause of the following exception:

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD263950>
mock_firestore = <MagicMock id='2472511159120'>

    def test_relato_state_progression(monkeypatch, mock_firestore):
        from app.services.relatos_background import _save_files_and_enqueue
    
>       monkeypatch.setattr(
            "app.services.relatos_background.salvar_imagem_bytes_to_storage",
            lambda *a, **k: "http://fake.url"
        )

tests\relato\test_relato_update_status_sync.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\_pytest\monkeypatch.py:104: in derive_importpath
    annotated_getattr(target, attr, ann=module)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

obj = <module 'app.services.relatos_background' from 'D:\\workspace_projects_001\\dermasync-api\\app\\services\\relatos_background.py'>
name = 'salvar_imagem_bytes_to_storage', ann = 'app.services.relatos_background'

    def annotated_getattr(obj: object, name: str, ann: str) -> object:
        try:
            obj = getattr(obj, name)
        except AttributeError as e:
>           raise AttributeError(
                f"{type(obj).__name__!r} object at {ann} has no attribute {name!r}"
            ) from e
E           AttributeError: 'module' object at app.services.relatos_background has no attribute 'salvar_imagem_bytes_to_storage'

venv\Lib\site-packages\_pytest\monkeypatch.py:92: AttributeError
____________________ test_invalid_status_transition_raises ____________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD1AFB10>
mock_firestore = <MagicMock id='2472510418896'>

    def test_invalid_status_transition_raises(monkeypatch, mock_firestore):
>       from app.services.relatos_background import update_relato_status_sync
E       ImportError: cannot import name 'update_relato_status_sync' from 'app.services.relatos_background' (D:\workspace_projects_001\dermasync-api\app\services\relatos_background.py)

tests\relato\test_relato_update_status_sync.py:114: ImportError
___________________________ test_error_is_terminal ____________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD169FD0>
mock_firestore = <MagicMock id='2472510133072'>

    def test_error_is_terminal(monkeypatch, mock_firestore):
>       from app.services.relatos_background import update_relato_status_sync
E       ImportError: cannot import name 'update_relato_status_sync' from 'app.services.relatos_background' (D:\workspace_projects_001\dermasync-api\app\services\relatos_background.py)

tests\relato\test_relato_update_status_sync.py:135: ImportError
_________________ test_get_relatos_com_autenticacao_permitida _________________

client = <httpx.AsyncClient object at 0x0000023FAD25B050>
mock_current_user_colaborador = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x0000023FAD258350>

    @pytest.mark.asyncio
    async def test_get_relatos_com_autenticacao_permitida(client: AsyncClient, mock_current_user_colaborador, mocker):
        """
        Testa se a rota de listar relatos funciona para um usu├írio com permiss├úo (colaborador).
        """
        mocker.patch("app.services.relatos_service.listar_relatos", return_value=[])
        response = await client.get("/relatos/listar-todos")
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\relato\test_relatos.py:20: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:54,690", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:54,820", "level": "INFO", "logger": "root", "message": "GET /relatos/listar-todos 127.0.0.1 -> 404 (100.3ms) body_len=0"}
{"timestamp": "2026-01-27 11:57:54,822", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/relatos/listar-todos \"HTTP/1.1 404 Not Found\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:54] [INFO] [request_logger] GET /relatos/listar-todos Status: 404 Tempo: 97.97ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:54 [INFO] GET /relatos/listar-todos 127.0.0.1 -> 404 (100.3ms) body_len=0
2026-01-27 11:57:54 [INFO] HTTP Request: GET http://test/relatos/listar-todos "HTTP/1.1 404 Not Found"
__________________ test_get_relatos_com_autenticacao_negada ___________________

client = <httpx.AsyncClient object at 0x0000023FAD4E8A50>
mock_current_user_usuario_logado = None

    @pytest.mark.asyncio
    async def test_get_relatos_com_autenticacao_negada(client: AsyncClient, mock_current_user_usuario_logado):
        """
        Testa se a rota de listar relatos bloqueia usu├írios sem permiss├úo (usuario_logado).
        """
        response = await client.get("/relatos/listar-todos")
>       assert response.status_code == status.HTTP_403_FORBIDDEN
E       assert 404 == 403
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   403 = status.HTTP_403_FORBIDDEN

tests\relato\test_relatos.py:31: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:54,863", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:54,947", "level": "INFO", "logger": "root", "message": "GET /relatos/listar-todos 127.0.0.1 -> 404 (60.3ms) body_len=0"}
{"timestamp": "2026-01-27 11:57:54,948", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/relatos/listar-todos \"HTTP/1.1 404 Not Found\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:54] [INFO] [request_logger] GET /relatos/listar-todos Status: 404 Tempo: 58.40ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:54 [INFO] GET /relatos/listar-todos 127.0.0.1 -> 404 (60.3ms) body_len=0
2026-01-27 11:57:54 [INFO] HTTP Request: GET http://test/relatos/listar-todos "HTTP/1.1 404 Not Found"
_________________________ test_get_relatos_com_admin __________________________

client = <httpx.AsyncClient object at 0x0000023FAD2BE0D0>
mock_current_user_admin = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x0000023FAD268A90>

    @pytest.mark.asyncio
    async def test_get_relatos_com_admin(client: AsyncClient, mock_current_user_admin, mocker):
        """
        Testa se a rota de listar relatos funciona para um usu├írio com permiss├úo de admin.
        """
        # Mock para a fun├º├úo que busca os relatos no banco de dados
        mocker.patch("app.services.relatos_service.listar_relatos", return_value=[{"id": "1", "conteudo": "Relato de teste"}])
    
        response = await client.get("/relatos/listar-todos")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\relato\test_relatos_admin.py:15: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:54,976", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:55,063", "level": "INFO", "logger": "root", "message": "GET /relatos/listar-todos 127.0.0.1 -> 404 (59.5ms) body_len=0"}
{"timestamp": "2026-01-27 11:57:55,064", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/relatos/listar-todos \"HTTP/1.1 404 Not Found\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:55] [INFO] [request_logger] GET /relatos/listar-todos Status: 404 Tempo: 58.44ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:55 [INFO] GET /relatos/listar-todos 127.0.0.1 -> 404 (59.5ms) body_len=0
2026-01-27 11:57:55 [INFO] HTTP Request: GET http://test/relatos/listar-todos "HTTP/1.1 404 Not Found"
_________________ test_enviar_relato_falha_firestore_rollback _________________

client = <httpx.AsyncClient object at 0x0000023FAD2C5350>
mock_current_user_usuario_logado = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x0000023FAD2C67D0>

    @pytest.mark.asyncio
    async def test_enviar_relato_falha_firestore_rollback(
        client: AsyncClient, mock_current_user_usuario_logado, mocker
    ):
        """
        Testa se o rollback de imagens ├® acionado quando salvar o relato no Firestore falha.
        """
        # Mock the environment variable for Firebase Storage Bucket
        mocker.patch("os.getenv", side_effect=lambda key, default=None: "test-bucket" if key == "FIREBASE_STORAGE_BUCKET" else default)
        # Mock para simular sucesso no salvamento da imagem
        mocker.patch(
            "app.services.relatos_service.salvar_imagem_from_base64",
            return_value={"id": "mock_image_id_rollback"},
        )
    
        # Mock para simular falha ao salvar no Firestore
        mocker.patch(
            "app.services.relatos_service.salvar_relato_firestore",
            side_effect=Exception("Falha ao conectar com o Firestore"),
        )
    
        # Mock para espionar a chamada da fun├º├úo de rollback
        mocker.patch(
            "app.services.relatos_service.mark_image_as_orphaned",
            return_value=None,
        )
        # Mock for enqueue_relato_processing
        mocker.patch("app.services.relatos_service.enqueue_relato_processing", return_value=None)
    
        payload = criar_payload_valido()
        response = await client.post("/relatos/completo", json=payload)
    
        # A requisi├º├úo deve falhar com um erro de servidor
>       assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
E       assert 405 == 500
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   500 = status.HTTP_500_INTERNAL_SERVER_ERROR

tests\relato\test_relatos_avancado.py:57: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:55,110", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:55,332", "level": "INFO", "logger": "root", "message": "POST /relatos/completo 127.0.0.1 -> 405 (2.5ms) body_len=1355"}
{"timestamp": "2026-01-27 11:57:55,338", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://test/relatos/completo \"HTTP/1.1 405 Method Not Allowed\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:55] [INFO] [request_logger] POST /relatos/completo Status: 405 Tempo: 2.00ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:55 [INFO] POST /relatos/completo 127.0.0.1 -> 405 (2.5ms) body_len=1355
2026-01-27 11:57:55 [INFO] HTTP Request: POST http://test/relatos/completo "HTTP/1.1 405 Method Not Allowed"
_____________________________ test_get_my_relatos _____________________________

client = <httpx.AsyncClient object at 0x0000023FAD4F7490>
mock_current_user_usuario_logado = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x0000023FAD4F7890>

    @pytest.mark.asyncio
    async def test_get_my_relatos(
        client: AsyncClient, mock_current_user_usuario_logado, mocker
    ):
        """
        Testa se a rota GET /relatos/me retorna apenas os relatos do usu├írio autenticado.
        """
        # Mock para a fun├º├úo do servi├ºo
        mock_get_relatos = mocker.patch(
            "app.services.relatos_service.get_relatos_by_owner_id",
            return_value=[{"id": "relato_meu_1"}, {"id": "relato_meu_2"}],
        )
        response = await client.get("/relatos/me")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\relato\test_relatos_avancado.py:78: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:55,393", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:55,469", "level": "INFO", "logger": "root", "message": "GET /relatos/me 127.0.0.1 -> 404 (56.3ms) body_len=0"}
{"timestamp": "2026-01-27 11:57:55,473", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/relatos/me \"HTTP/1.1 404 Not Found\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:55] [INFO] [request_logger] GET /relatos/me Status: 404 Tempo: 53.18ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:55 [INFO] GET /relatos/me 127.0.0.1 -> 404 (56.3ms) body_len=0
2026-01-27 11:57:55 [INFO] HTTP Request: GET http://test/relatos/me "HTTP/1.1 404 Not Found"
_______________________ test_get_single_relato_as_owner _______________________

client = <httpx.AsyncClient object at 0x0000023FAD56CB90>
mock_current_user_usuario_logado = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x0000023FAD56C8D0>

    @pytest.mark.asyncio
    async def test_get_single_relato_as_owner(
        client: AsyncClient, mock_current_user_usuario_logado, mocker
    ):
        """
        Testa o acesso a um relato espec├¡fico pelo propriet├írio.
        """
        # Mock para a fun├º├úo do servi├ºo com todos os campos necess├írios para RelatoFullOutput
        mock_get_relato = mocker.patch(
            "app.services.relatos_service.get_relato_by_id",
            return_value={
                "id": "relato_123",
                "id_relato_cliente": "relato_cliente_123",
                "owner_user_id": "user_123", # MODIFIED
                "timestamp": "2023-01-01T00:00:00Z",
                "conteudo_original": "Conte├║do completo.",
                "classificacao_etaria": "adulto",
                "idade": "30",
                "genero": "feminino",
                "sintomas": ["dor"],
                "imagens_ids": {"antes": "img_a", "durante": [], "depois": None},
                "regioes_afetadas": ["cabe├ºa"],
                "status": "novo",
                "micro_depoimento": None,
                "solucao_encontrada": None,
            },
        )
    
        response = await client.get("/relatos/relato_123")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\relato\test_relatos_avancado.py:116: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:55,512", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:55,593", "level": "INFO", "logger": "root", "message": "GET /relatos/relato_123 127.0.0.1 -> 404 (60.6ms) body_len=0"}
{"timestamp": "2026-01-27 11:57:55,595", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/relatos/relato_123 \"HTTP/1.1 404 Not Found\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:55] [INFO] [request_logger] GET /relatos/relato_123 Status: 404 Tempo: 59.64ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:55 [INFO] GET /relatos/relato_123 127.0.0.1 -> 404 (60.6ms) body_len=0
2026-01-27 11:57:55 [INFO] HTTP Request: GET http://test/relatos/relato_123 "HTTP/1.1 404 Not Found"
_________________________ test_attach_image_to_relato _________________________

client = <httpx.AsyncClient object at 0x0000023FAD26AE10>
mock_current_user_usuario_logado = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x0000023FAD2CE690>

    @pytest.mark.asyncio
    async def test_attach_image_to_relato(
        client: AsyncClient, mock_current_user_usuario_logado, mocker
    ):
        """
        Testa o endpoint para anexar uma imagem a um relato.
        """
        # --- Start Firestore Mock ---
        mock_relato_data = {
            "id": "relato_123",
            "id_relato_cliente": "relato_cliente_123",
            "owner_user_id": "user_123",
            "timestamp": "2023-01-01T00:00:00Z",
            "conteudo_original": "Conte├║do original do relato.",
            "classificacao_etaria": "adulto",
            "idade": "30",
            "genero": "feminino",
            "sintomas": ["dor"],
            "imagens_ids": {"antes": None, "durante": [], "depois": None},
            "regioes_afetadas": ["cabe├ºa"],
            "status": "novo",
            "micro_depoimento": None,
            "solucao_encontrada": None,
        }
    
        # Mock for Relato Document
        mock_relato_doc_snapshot = mocker.Mock()
        mock_relato_doc_snapshot.exists = True
        mock_relato_doc_snapshot.to_dict.side_effect = lambda: mock_relato_data.copy()
    
        mock_relato_doc_ref = mocker.Mock()
        mock_relato_doc_ref.get.return_value = mock_relato_doc_snapshot
        mock_relato_doc_ref.update = mocker.AsyncMock(return_value=None)
    
    
        # Mock for Image Document (Separate mock for image document reference)
        mock_image_firestore_data = {
            "id": "new_image_id",
            "owner_user_id": "user_123",
            "status": "raw",
            "original_filename": "new_image.jpg",
            "content_type": "image/jpeg",
            "size_bytes": 500,
            "width": 50,
            "height": 50,
            "sha256": "somehash_img",
            "storage_path": "raw/user_123/new_image.jpg",
            "created_at": "2023-01-01T00:00:00Z",
            "updated_at": "2023-01-01T00:00:00Z",
        }
        mock_image_doc_snapshot = mocker.Mock()
        mock_image_doc_snapshot.exists = True
        mock_image_doc_snapshot.to_dict.side_effect = lambda: mock_image_firestore_data.copy()
    
        mock_image_doc_ref = mocker.Mock()
        mock_image_doc_ref.get.return_value = mock_image_doc_snapshot
        mock_image_doc_ref.update = mocker.AsyncMock(return_value=None)
    
    
        # Mock the db.collection("relatos").document(relato_id) chain
        mock_relato_collection = mocker.Mock()
        mock_relato_collection.document.return_value = mock_relato_doc_ref
    
        # Mock the db.collection("imagens").document(image_id) chain
        mock_imagens_collection = mocker.Mock()
        mock_imagens_collection.document.return_value = mock_image_doc_ref
    
    
        mock_db = mocker.Mock()
        mock_db.collection.side_effect = lambda name: {
            "relatos": mock_relato_collection,
            "imagens": mock_imagens_collection,
        }[name]
    
        mocker.patch("app.services.relatos_service.get_firestore_client", return_value=mock_db)
        mocker.patch("app.services.imagens_service.get_firestore_client", return_value=mock_db)
        # --- End Firestore Mock ---
    
        # Mock for get_imagem_by_id, which is also called internally by attach_image_to_relato
        mocker.patch(
            "app.services.imagens_service.get_imagem_by_id",
            return_value={
                "id": "new_image_id",
                "owner_user_id": "user_123",
                "status": "raw",
                "original_filename": "new_image.jpg",
                "content_type": "image/jpeg",
                "size_bytes": 500,
                "width": 50,
                "height": 50,
                "sha256": "somehash_img",
                "storage_path": "raw/user_123/new_image.jpg",
                "created_at": "2023-01-01T00:00:00Z",
                "updated_at": "2023-01-01T00:00:00Z",
            },
        )
        # Mock for mark_image_as_orphaned to prevent actual DB calls during rollback scenario
        mocker.patch("app.services.imagens_service.mark_image_as_orphaned", return_value=None)
    
    
        # Mock the service function attach_image_to_relato itself, and allow it to run with mocked Firestore
        # The return_value should match what the *endpoint* expects after the service call
        # In this case, the endpoint expects RelatoFullOutput, which attach_image_to_relato returns
        # So we can let the actual service function run with its mocked dependencies.
        # We DO NOT mock attach_image_to_relato directly if we want to test its internal logic.
        # Instead, we mock its dependencies (Firestore, get_imagem_by_id).
    
        response = await client.post(
            "/relatos/relato_123/attach-image",
            json={"image_id": "new_image_id"},
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\relato\test_relatos_avancado.py:239: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:55,630", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:55,673", "level": "INFO", "logger": "root", "message": "POST /relatos/relato_123/attach-image 127.0.0.1 -> 404 (2.0ms) body_len=27"}
{"timestamp": "2026-01-27 11:57:55,675", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://test/relatos/relato_123/attach-image \"HTTP/1.1 404 Not Found\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:55] [INFO] [request_logger] POST /relatos/relato_123/attach-image Status: 404 Tempo: 0.96ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:55 [INFO] POST /relatos/relato_123/attach-image 127.0.0.1 -> 404 (2.0ms) body_len=27
2026-01-27 11:57:55 [INFO] HTTP Request: POST http://test/relatos/relato_123/attach-image "HTTP/1.1 404 Not Found"
_________________________ test_get_moderation_pending _________________________

client = <httpx.AsyncClient object at 0x0000023FAD2C4C50>
mock_current_user_admin = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x0000023FAD277750>

    @pytest.mark.asyncio
    async def test_get_moderation_pending(
        client: AsyncClient, mock_current_user_admin, mocker
    ):
        """
        Testa o acesso ├á lista de relatos pendentes de modera├º├úo por um admin.
        """
        mocker.patch(
            "app.services.relatos_service.list_pending_moderation_relatos", # MODIFIED PATCH TARGET
            return_value=[
                {
                    "id": "relato_proc_1",
                    "id_relato_cliente": "client_relato_1",
                    "owner_user_id": "user_123",
                    "timestamp": "2023-01-01T00:00:00Z",
                    "conteudo_original": "Conte├║do processado 1.",
                    "classificacao_etaria": "adulto",
                    "idade": "25",
                    "genero": "masculino",
                    "sintomas": ["dor", "incha├ºo"],
                    "imagens_ids": {"antes": "img_a", "durante": [], "depois": None},
                    "regioes_afetadas": ["perna"],
                    "status": "processed",
                    "micro_depoimento": "Resumo 1.",
                    "solucao_encontrada": "Solu├º├úo 1.",
                }
            ],
        )
    
        response = await client.get("/relatos/moderation/pending")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\relato\test_relatos_avancado.py:283: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:55,711", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:55,733", "level": "INFO", "logger": "root", "message": "GET /relatos/moderation/pending 127.0.0.1 -> 404 (2.0ms) body_len=0"}
{"timestamp": "2026-01-27 11:57:55,736", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/relatos/moderation/pending \"HTTP/1.1 404 Not Found\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:55] [INFO] [request_logger] GET /relatos/moderation/pending Status: 404 Tempo: 1.00ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:55 [INFO] GET /relatos/moderation/pending 127.0.0.1 -> 404 (2.0ms) body_len=0
2026-01-27 11:57:55 [INFO] HTTP Request: GET http://test/relatos/moderation/pending "HTTP/1.1 404 Not Found"
__________________________ test_update_relato_status __________________________

client = <httpx.AsyncClient object at 0x0000023FAD57B010>
mock_current_user_admin = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x0000023FAD57AF10>

    @pytest.mark.asyncio
    async def test_update_relato_status(
        client: AsyncClient, mock_current_user_admin, mocker
    ):
        """
        Testa a atualiza├º├úo de status de um relato por um admin.
        """
        # --- Start Firestore Mock ---
        mock_relato_data = {
            "id": "relato_123",
            "id_relato_cliente": "relato_cliente_123",
            "owner_user_id": "user_123",
            "timestamp": "2023-01-01T00:00:00Z",
            "conteudo_original": "Conte├║do original do relato.",
            "classificacao_etaria": "adulto",
            "idade": "30",
            "genero": "feminino",
            "sintomas": ["dor"],
            "imagens_ids": {"antes": None, "durante": [], "depois": None},
            "regioes_afetadas": ["cabe├ºa"],
            "status": "novo",
            "micro_depoimento": None,
            "solucao_encontrada": None,
        }
    
        # Mock for Relato Document
        mock_relato_doc_snapshot = mocker.Mock()
        mock_relato_doc_snapshot.exists = True
        mocker.patch.object(mock_relato_doc_snapshot, 'to_dict', return_value=mock_relato_data.copy())
    
        mock_relato_doc_ref = mocker.Mock()
        mock_relato_doc_ref.get.return_value = mock_relato_doc_snapshot
        mock_relato_doc_ref.update = mocker.AsyncMock(return_value=None)
    
        # Mock the db.collection("relatos").document(relato_id) chain
        mock_relato_collection = mocker.Mock()
        mock_relato_collection.document.return_value = mock_relato_doc_ref
    
        mock_db = mocker.Mock()
        mock_db.collection.side_effect = lambda name: {
            "relatos": mock_relato_collection,
        }[name] # Only mock 'relatos' collection as only that is used directly here
    
        mocker.patch("app.services.relatos_service.get_firestore_client", return_value=mock_db)
        # The imagens_service get_firestore_client is not directly called here, so no need to mock it.
        # --- End Firestore Mock ---
    
        # We do NOT mock update_relato_status directly. Instead, we mock its dependencies (Firestore).
    
        response = await client.patch(
            "/relatos/relato_123/status",
            json={"new_status": "approved_public"},
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 405 == 200
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\relato\test_relatos_avancado.py:343: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:55,771", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:55,811", "level": "INFO", "logger": "root", "message": "PATCH /relatos/relato_123/status 127.0.0.1 -> 405 (1.6ms) body_len=32"}
{"timestamp": "2026-01-27 11:57:55,813", "level": "INFO", "logger": "httpx", "message": "HTTP Request: PATCH http://test/relatos/relato_123/status \"HTTP/1.1 405 Method Not Allowed\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:55] [INFO] [request_logger] PATCH /relatos/relato_123/status Status: 405 Tempo: 1.56ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:55 [INFO] PATCH /relatos/relato_123/status 127.0.0.1 -> 405 (1.6ms) body_len=32
2026-01-27 11:57:55 [INFO] HTTP Request: PATCH http://test/relatos/relato_123/status "HTTP/1.1 405 Method Not Allowed"
_____________________ test_enviar_relato_sem_autenticacao _____________________

client = <httpx.AsyncClient object at 0x0000023FAD187E50>

    @pytest.mark.asyncio
    async def test_enviar_relato_sem_autenticacao(client: AsyncClient):
        """
        Testa se a rota de enviar relato retorna 401/403 sem autentica├º├úo.
        """
        payload = criar_payload_valido()
        response = await client.post("/relatos/completo", json=payload)
>       assert response.status_code in [status.HTTP_401_UNAUTHORIZED, status.HTTP_403_FORBIDDEN]
E       assert 405 in [401, 403]
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code

tests\relato\test_relatos_enviar.py:30: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:55,849", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:55,871", "level": "INFO", "logger": "root", "message": "POST /relatos/completo 127.0.0.1 -> 405 (3.0ms) body_len=3576"}
{"timestamp": "2026-01-27 11:57:55,874", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://test/relatos/completo \"HTTP/1.1 405 Method Not Allowed\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:55] [INFO] [request_logger] POST /relatos/completo Status: 405 Tempo: 1.02ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:55 [INFO] POST /relatos/completo 127.0.0.1 -> 405 (3.0ms) body_len=3576
2026-01-27 11:57:55 [INFO] HTTP Request: POST http://test/relatos/completo "HTTP/1.1 405 Method Not Allowed"
_____________________ test_enviar_relato_com_autenticacao _____________________

client = <httpx.AsyncClient object at 0x0000023FAD56C910>
mock_current_user_usuario_logado = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x0000023FAD277C50>

    @pytest.mark.asyncio
    async def test_enviar_relato_com_autenticacao(client: AsyncClient, mock_current_user_usuario_logado, mocker):
        """
        Testa se a rota de enviar relato funciona com autentica├º├úo.
        """
        mocker.patch("app.services.relatos_service.salvar_relato_firestore", return_value="mock_doc_id")
        mocker.patch(
            "app.services.relatos_service.salvar_imagem_from_base64",
            return_value={"id": "mock_image_id"},
        )
        mocker.patch("app.services.relatos_service.mark_image_as_orphaned", return_value=None)
        mocker.patch("app.services.relatos_service.enqueue_relato_processing", return_value=None)
        # Mock the environment variable for Firebase Storage Bucket
        mocker.patch("os.getenv", side_effect=lambda key, default=None: "test-bucket" if key == "FIREBASE_STORAGE_BUCKET" else default)
    
        payload = criar_payload_valido()
        response = await client.post("/relatos/completo", json=payload)
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 405 == 200
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\relato\test_relatos_enviar.py:50: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:55,927", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:55,960", "level": "INFO", "logger": "root", "message": "POST /relatos/completo 127.0.0.1 -> 405 (2.1ms) body_len=3576"}
{"timestamp": "2026-01-27 11:57:55,962", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://test/relatos/completo \"HTTP/1.1 405 Method Not Allowed\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:55] [INFO] [request_logger] POST /relatos/completo Status: 405 Tempo: 0.96ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:55 [INFO] POST /relatos/completo 127.0.0.1 -> 405 (2.1ms) body_len=3576
2026-01-27 11:57:55 [INFO] HTTP Request: POST http://test/relatos/completo "HTTP/1.1 405 Method Not Allowed"
________________ test_post_relatos_with_real_multipart_upload _________________

    def test_post_relatos_with_real_multipart_upload():
    
    
        # -----------------------------------
        # Auth override (correto)
        # -----------------------------------
        mock_user = User(
            id="user-123",
            email="user@test.com",
            role="usuario_logado"
        )
    
        app.dependency_overrides[get_current_user] = lambda: mock_user
        client = TestClient(app)
    
        # -----------------------------------
        # Payload v├ílido (schema real)
        # -----------------------------------
        payload = {
            "descricao": "Relato com imagem real",
            "consentimento": True,
            "idade": 33
        }
    
        # -----------------------------------
        # Arquivo real em mem├│ria
        # -----------------------------------
        fake_image_bytes = BytesIO(b"fake-image-bytes-123")
        fake_image_bytes.name = "antes.jpg"
    
        files = {
            "imagens_antes": (
                "antes.jpg",
                fake_image_bytes,
                "image/jpeg",
            )
        }
    
        try:
            # -----------------------------------
            # Mock SOMENTE do executor
            # -----------------------------------
            with patch("app.routes.relatos.RelatoEffectExecutor") as mock_exec:
                exec_instance = MagicMock()
                mock_exec.return_value = exec_instance
    
                response = client.post(
                    "/relatos/",
                    data={"payload": json.dumps(payload)},
                    files=files,
                )
    
                # -----------------------------------
                # Asser├º├Áes cr├¡ticas
                # -----------------------------------
                assert response.status_code == 201
    
                body = response.json()
>               assert "relato_id" in body
E               AssertionError: assert 'relato_id' in {'data': {'relato_id': '29f6a94a9d724fbea50c8af942d6a3b3', 'status': 'created'}, 'ux_effects': [{'channel': 'progress', 'message': 'Relato recebido e salvo.', 'relato_id': '29f6a94a9d724fbea50c8af942d6a3b3', 'severity': 'info', ...}, {'channel': 'progress', 'message': 'Imagens enviadas para processamento.', 'relato_id': '29f6a94a9d724fbea50c8af942d6a3b3', 'severity': 'info', ...}]}

tests\routes\test_relatos_multipart.py:68: AssertionError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:56,202", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
{"timestamp": "2026-01-27 11:57:56,222", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_part_begin with no data"}
{"timestamp": "2026-01-27 11:57:56,222", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_header_field with data[36:55]"}
{"timestamp": "2026-01-27 11:57:56,223", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_header_value with data[57:82]"}
{"timestamp": "2026-01-27 11:57:56,223", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_header_end with no data"}
{"timestamp": "2026-01-27 11:57:56,223", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_headers_finished with no data"}
{"timestamp": "2026-01-27 11:57:56,223", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_part_data with data[86:161]"}
{"timestamp": "2026-01-27 11:57:56,224", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_part_end with no data"}
{"timestamp": "2026-01-27 11:57:56,224", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_part_begin with no data"}
{"timestamp": "2026-01-27 11:57:56,225", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_header_field with data[199:218]"}
{"timestamp": "2026-01-27 11:57:56,225", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_header_value with data[220:273]"}
{"timestamp": "2026-01-27 11:57:56,225", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_header_end with no data"}
{"timestamp": "2026-01-27 11:57:56,225", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_header_field with data[275:287]"}
{"timestamp": "2026-01-27 11:57:56,225", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_header_value with data[289:299]"}
{"timestamp": "2026-01-27 11:57:56,225", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_header_end with no data"}
{"timestamp": "2026-01-27 11:57:56,225", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_headers_finished with no data"}
{"timestamp": "2026-01-27 11:57:56,226", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_part_data with data[303:323]"}
{"timestamp": "2026-01-27 11:57:56,226", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_part_end with no data"}
{"timestamp": "2026-01-27 11:57:56,226", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_end with no data"}
{"timestamp": "2026-01-27 11:57:56,237", "level": "INFO", "logger": "root", "message": "POST /relatos/ testclient -> 201 (20.0ms) body_len=363"}
{"timestamp": "2026-01-27 11:57:56,242", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://testserver/relatos/ \"HTTP/1.1 201 Created\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:56] [INFO] [request_logger] POST /relatos/ Status: 201 Tempo: 16.38ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:56 [INFO] POST /relatos/ testclient -> 201 (20.0ms) body_len=363
2026-01-27 11:57:56 [INFO] HTTP Request: POST http://testserver/relatos/ "HTTP/1.1 201 Created"
____________________ test_upload_failure_triggers_rollback ____________________

    def test_upload_failure_triggers_rollback():
        from app.services.relato_effect_executor import RelatoEffectExecutor
        from app.domain.relato.effects import UploadImagesEffect, RollbackImagesEffect
    
        upload_called = False
        rollback_called = False
    
        def fake_upload(relato_id, imagens):
            nonlocal upload_called
            upload_called = True
            raise RuntimeError("upload failed")
    
        def fake_rollback(image_ids):
            nonlocal rollback_called
            rollback_called = True
    
    
        executor = RelatoEffectExecutor(
            upload_images=fake_upload,
            rollback_images=fake_rollback,
            persist_relato=lambda e: None,
            enqueue_processing=lambda e: None,
            emit_event=lambda e: None,
            update_relato_status=lambda e: None,
    
        )
    
        effects = [
>           UploadImagesEffect(relato_id="r1", imagens={})
        ]
E       TypeError: UploadImagesEffect.__init__() got an unexpected keyword argument 'imagens'

tests\routes\test_relatos_multipart.py:106: TypeError
__________________________ test_post_relatos_success __________________________

    def test_post_relatos_success():
        """Testa a cria├º├úo bem-sucedida de um relato (status 201)."""
        # Mock dependencies
        mock_user = User(id="user-123", email="test@example.com", role="usuario_logado")
    
        # Mock the domain decision
        mock_decision = Decision(
            allowed=True,
            reason=None,
>           next_state=RelatoStatus.DRAFT,
                       ^^^^^^^^^^^^^^^^^^
            previous_state=None,
            effects=["effect1", "effect2"]  # Mock effects
        )

tests\routes\test_relatos_post.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <enum 'RelatoStatus'>, name = 'DRAFT'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
>           raise AttributeError(name) from None
E           AttributeError: DRAFT

C:\Python311\Lib\enum.py:783: AttributeError
_____________________ test_post_relatos_denied_by_domain ______________________

    def test_post_relatos_denied_by_domain():
        """Testa que a rota retorna 403 quando o dom├¡nio nega a cria├º├úo."""
        # Mock dependencies
        mock_user = User(id="user-123", email="test@example.com", role="usuario_logado")
    
        # Mock the domain decision (denied)
        mock_decision = Decision(
            allowed=False,
            reason="Relato j├í existe.",
            next_state=None,
>           previous_state=RelatoStatus.DRAFT,
                           ^^^^^^^^^^^^^^^^^^
            effects=[]  # No effects when denied
        )

tests\routes\test_relatos_post.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <enum 'RelatoStatus'>, name = 'DRAFT'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
>           raise AttributeError(name) from None
E           AttributeError: DRAFT

C:\Python311\Lib\enum.py:783: AttributeError
___________________ test_post_relatos_missing_consentimento ___________________

    def test_post_relatos_missing_consentimento():
        """Testa que a rota retorna 400 quando consentimento n├úo ├® informado."""
        # Mock dependencies
        mock_user = User(id="user-123", email="test@example.com", role="usuario_logado")
    
        # Create a test client
        client = TestClient(app)
    
        # Prepare payload without consentimento
        payload = {
            "descricao": "Relato de teste",
            "consentimento": False,  # Explicitly false
            "tags": ["teste"],
            "tratamentos": ["tratamento1"]
        }
    
        with patch("app.auth.dependencies.get_current_user", return_value=mock_user):
            # Make the request
            response = client.post(
                "/relatos",
                data={"payload": json.dumps(payload)},
            )
    
            # Assertions
>           assert response.status_code == status.HTTP_400_BAD_REQUEST
E           assert 401 == 400
E            +  where 401 = <Response [401 Unauthorized]>.status_code
E            +  and   400 = status.HTTP_400_BAD_REQUEST

tests\routes\test_relatos_post.py:140: AssertionError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:56,887", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
{"timestamp": "2026-01-27 11:57:56,909", "level": "INFO", "logger": "root", "message": "POST /relatos testclient -> 307 (4.2ms) body_len=169"}
{"timestamp": "2026-01-27 11:57:56,913", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://testserver/relatos \"HTTP/1.1 307 Temporary Redirect\""}
{"timestamp": "2026-01-27 11:57:56,914", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
{"timestamp": "2026-01-27 11:57:56,933", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_start with no data"}
{"timestamp": "2026-01-27 11:57:56,933", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_name with data[0:7]"}
{"timestamp": "2026-01-27 11:57:56,934", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_data with data[8:169]"}
{"timestamp": "2026-01-27 11:57:56,934", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_end with no data"}
{"timestamp": "2026-01-27 11:57:56,934", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_end with no data"}
{"timestamp": "2026-01-27 11:57:56,938", "level": "DEBUG", "logger": "app.auth.dependencies", "message": "Auth dependency: Authorization header raw -> None"}
{"timestamp": "2026-01-27 11:57:56,939", "level": "INFO", "logger": "app.auth.dependencies", "message": "AUTH REJECT: Authorization header ausente."}
{"timestamp": "2026-01-27 11:57:56,943", "level": "INFO", "logger": "root", "message": "POST /relatos/ testclient -> 401 (12.2ms) body_len=169"}
{"timestamp": "2026-01-27 11:57:56,948", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://testserver/relatos/ \"HTTP/1.1 401 Unauthorized\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:56] [INFO] [request_logger] POST /relatos Status: 307 Tempo: 1.60ms[0m
[32m[2026-01-27 11:57:56] [INFO] [request_logger] POST /relatos/ Status: 401 Tempo: 9.21ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:56 [INFO] POST /relatos testclient -> 307 (4.2ms) body_len=169
2026-01-27 11:57:56 [INFO] HTTP Request: POST http://testserver/relatos "HTTP/1.1 307 Temporary Redirect"
2026-01-27 11:57:56 [INFO] AUTH REJECT: Authorization header ausente.
2026-01-27 11:57:56 [INFO] POST /relatos/ testclient -> 401 (12.2ms) body_len=169
2026-01-27 11:57:56 [INFO] HTTP Request: POST http://testserver/relatos/ "HTTP/1.1 401 Unauthorized"
__________________ test_post_relatos_no_consentimento_field ___________________

    def test_post_relatos_no_consentimento_field():
        """Testa que a rota retorna 400 quando campo consentimento est├í ausente."""
        # Mock dependencies
        mock_user = User(id="user-123", email="test@example.com", role="usuario_logado")
    
        # Create a test client
        client = TestClient(app)
    
        # Prepare payload without consentimento field
        payload = {
            "descricao": "Relato de teste",
            "tags": ["teste"],
            "tratamentos": ["tratamento1"]
        }
    
        with patch("app.auth.dependencies.get_current_user", return_value=mock_user):
            # Make the request
            response = client.post(
                "/relatos",
                data={"payload": json.dumps(payload)},
            )
    
            # Assertions - this might be a validation error depending on schema
            # If the schema requires consentimento, this will be 422, otherwise 400 if checked in code
>           assert response.status_code in [status.HTTP_400_BAD_REQUEST, status.HTTP_422_UNPROCESSABLE_ENTITY]
E           assert 401 in [400, 422]
E            +  where 401 = <Response [401 Unauthorized]>.status_code

tests\routes\test_relatos_post.py:169: AssertionError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:56,984", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
{"timestamp": "2026-01-27 11:57:57,003", "level": "INFO", "logger": "root", "message": "POST /relatos testclient -> 307 (2.9ms) body_len=137"}
{"timestamp": "2026-01-27 11:57:57,008", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://testserver/relatos \"HTTP/1.1 307 Temporary Redirect\""}
{"timestamp": "2026-01-27 11:57:57,009", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
{"timestamp": "2026-01-27 11:57:57,028", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_start with no data"}
{"timestamp": "2026-01-27 11:57:57,029", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_name with data[0:7]"}
{"timestamp": "2026-01-27 11:57:57,029", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_data with data[8:137]"}
{"timestamp": "2026-01-27 11:57:57,029", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_field_end with no data"}
{"timestamp": "2026-01-27 11:57:57,029", "level": "DEBUG", "logger": "python_multipart.multipart", "message": "Calling on_end with no data"}
{"timestamp": "2026-01-27 11:57:57,032", "level": "DEBUG", "logger": "app.auth.dependencies", "message": "Auth dependency: Authorization header raw -> None"}
{"timestamp": "2026-01-27 11:57:57,032", "level": "INFO", "logger": "app.auth.dependencies", "message": "AUTH REJECT: Authorization header ausente."}
{"timestamp": "2026-01-27 11:57:57,034", "level": "INFO", "logger": "root", "message": "POST /relatos/ testclient -> 401 (8.3ms) body_len=137"}
{"timestamp": "2026-01-27 11:57:57,040", "level": "INFO", "logger": "httpx", "message": "HTTP Request: POST http://testserver/relatos/ \"HTTP/1.1 401 Unauthorized\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:57:57] [INFO] [request_logger] POST /relatos Status: 307 Tempo: 1.91ms[0m
[32m[2026-01-27 11:57:57] [INFO] [request_logger] POST /relatos/ Status: 401 Tempo: 7.26ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:57:57 [INFO] POST /relatos testclient -> 307 (2.9ms) body_len=137
2026-01-27 11:57:57 [INFO] HTTP Request: POST http://testserver/relatos "HTTP/1.1 307 Temporary Redirect"
2026-01-27 11:57:57 [INFO] AUTH REJECT: Authorization header ausente.
2026-01-27 11:57:57 [INFO] POST /relatos/ testclient -> 401 (8.3ms) body_len=137
2026-01-27 11:57:57 [INFO] HTTP Request: POST http://testserver/relatos/ "HTTP/1.1 401 Unauthorized"
______________ test_post_relatos_executor_not_called_when_denied ______________

    def test_post_relatos_executor_not_called_when_denied():
        """Testa que o executor de efeitos N├âO ├® chamado quando decision.allowed == False."""
        # Mock dependencies
        mock_user = User(id="user-123", email="test@example.com", role="usuario_logado")
    
        # Mock the domain decision (denied)
        mock_decision = Decision(
            allowed=False,
            reason="Relato j├í existe.",
            next_state=None,
>           previous_state=RelatoStatus.DRAFT,
                           ^^^^^^^^^^^^^^^^^^
            effects=[]  # No effects when denied
        )

tests\routes\test_relatos_post.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <enum 'RelatoStatus'>, name = 'DRAFT'

    def __getattr__(cls, name):
        """
        Return the enum member matching `name`
    
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
>           raise AttributeError(name) from None
E           AttributeError: DRAFT

C:\Python311\Lib\enum.py:783: AttributeError
_____________________ test_get_relato_progress_forbidden ______________________

client = <httpx.AsyncClient object at 0x0000023FAD316110>
mock_current_user_usuario_logado = None
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD316F10>

    @pytest.mark.asyncio
    async def test_get_relato_progress_forbidden(
        client,
        mock_current_user_usuario_logado,
        monkeypatch,
    ):
        from fastapi import HTTPException
    
        async def fake_get_relato_by_id(*_, **__):
            raise HTTPException(status_code=403, detail="Acesso negado")
    
        monkeypatch.setattr(
            "app.services.relatos_service.get_relato_by_id",
            fake_get_relato_by_id,
        )
    
        response = await client.get("/relatos/relato-123/progress")
>       assert response.status_code == status.HTTP_403_FORBIDDEN
E       assert 200 == 403
E        +  where 200 = <Response [200 OK]>.status_code
E        +  and   403 = status.HTTP_403_FORBIDDEN

tests\routes\test_relatos_progress.py:38: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:57:57,230", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:57:57,250", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Getting progress for relato_id=relato-123 user=user_123"}
{"timestamp": "2026-01-27 11:58:02,267", "level": "DEBUG", "logger": "urllib3.connectionpool", "message": "Starting new HTTPS connection (1): oauth2.googleapis.com:443"}
{"timestamp": "2026-01-27 11:58:02,599", "level": "DEBUG", "logger": "urllib3.connectionpool", "message": "https://oauth2.googleapis.com:443 \"POST /token HTTP/1.1\" 200 None"}
{"timestamp": "2026-01-27 11:58:02,739", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Found 26 effect records for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:02,739", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Converted effect records to UXEffectRecords for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:02,739", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Sorted UXEffectRecords for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:02,739", "level": "DEBUG", "logger": "app.core.projections.progress_projector", "message": "Projecting progress for relato_id=relato-123 with 26 effects"}
{"timestamp": "2026-01-27 11:58:02,740", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Projected progress for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:02,745", "level": "INFO", "logger": "root", "message": "GET /relatos/relato-123/progress 127.0.0.1 -> 200 (5497.5ms) body_len=0"}
{"timestamp": "2026-01-27 11:58:02,748", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/relatos/relato-123/progress \"HTTP/1.1 200 OK\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:58:02] [INFO] [request_logger] GET /relatos/relato-123/progress Status: 200 Tempo: 5496.56ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:58:02 [INFO] GET /relatos/relato-123/progress 127.0.0.1 -> 200 (5497.5ms) body_len=0
2026-01-27 11:58:02 [INFO] HTTP Request: GET http://test/relatos/relato-123/progress "HTTP/1.1 200 OK"
_______________________ test_get_relato_progress_empty ________________________

client = <httpx.AsyncClient object at 0x0000023FAD561F10>
mock_current_user_usuario_logado = None
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD561A50>

    @pytest.mark.asyncio
    async def test_get_relato_progress_empty(
        client,
        mock_current_user_usuario_logado,
        monkeypatch,
    ):
        async def fake_get_relato_by_id(*_, **__):
            return {"id": "relato-123"}
    
        def fake_fetch_progress(relato_id: str):
            return {
                "relato_id": relato_id,
                "total_effects": 0,
                "completed": 0,
                "failed": 0,
                "progress_pct": 0,
                "effects": [],
            }
    
        monkeypatch.setattr(
            "app.services.relatos_service.get_relato_by_id",
            fake_get_relato_by_id,
        )
    
        monkeypatch.setattr(
            "app.services.readmodels.relato_progress.fetch_relato_progress",
            fake_fetch_progress,
        )
    
        response = await client.get("/relatos/relato-123/progress")
        data = response.json()
    
        assert response.status_code == 200
>       assert data["progress_pct"] == 0
E       assert 0.42857142857142855 == 0

tests\routes\test_relatos_progress.py:78: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:58:02,807", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:02,869", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Getting progress for relato_id=relato-123 user=user_123"}
{"timestamp": "2026-01-27 11:58:08,560", "level": "DEBUG", "logger": "urllib3.connectionpool", "message": "Starting new HTTPS connection (1): oauth2.googleapis.com:443"}
{"timestamp": "2026-01-27 11:58:08,800", "level": "DEBUG", "logger": "urllib3.connectionpool", "message": "https://oauth2.googleapis.com:443 \"POST /token HTTP/1.1\" 200 None"}
{"timestamp": "2026-01-27 11:58:08,943", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Found 26 effect records for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:08,944", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Converted effect records to UXEffectRecords for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:08,944", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Sorted UXEffectRecords for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:08,944", "level": "DEBUG", "logger": "app.core.projections.progress_projector", "message": "Projecting progress for relato_id=relato-123 with 26 effects"}
{"timestamp": "2026-01-27 11:58:08,944", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Projected progress for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:08,948", "level": "INFO", "logger": "root", "message": "GET /relatos/relato-123/progress 127.0.0.1 -> 200 (6085.5ms) body_len=0"}
{"timestamp": "2026-01-27 11:58:08,952", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/relatos/relato-123/progress \"HTTP/1.1 200 OK\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:58:08] [INFO] [request_logger] GET /relatos/relato-123/progress Status: 200 Tempo: 6082.47ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:58:08 [INFO] GET /relatos/relato-123/progress 127.0.0.1 -> 200 (6085.5ms) body_len=0
2026-01-27 11:58:08 [INFO] HTTP Request: GET http://test/relatos/relato-123/progress "HTTP/1.1 200 OK"
_________________ test_get_relato_progress_partial_with_error _________________

client = <httpx.AsyncClient object at 0x0000023FAD5B9050>
mock_current_user_usuario_logado = None
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD5BB4D0>

    @pytest.mark.asyncio
    async def test_get_relato_progress_partial_with_error(
        client,
        mock_current_user_usuario_logado,
        monkeypatch,
    ):
        async def fake_get_relato_by_id(*_, **__):
            return {"id": "relato-123"}
    
        def fake_fetch_progress(relato_id: str):
            return {
                "relato_id": relato_id,
                "total_effects": 3,
                "completed": 2,
                "failed": 1,
                "progress_pct": 66,
                "effects": [
                    {"effect_type": "PERSIST_RELATO", "success": True},
                    {"effect_type": "UPLOAD_IMAGES", "success": False},
                    {"effect_type": "ENQUEUE_PROCESSING", "success": True},
                ],
            }
    
        monkeypatch.setattr(
            "app.services.relatos_service.get_relato_by_id",
            fake_get_relato_by_id,
        )
    
        monkeypatch.setattr(
            "app.services.readmodels.relato_progress.fetch_relato_progress",
            fake_fetch_progress,
        )
    
        response = await client.get("/relatos/relato-123/progress")
        data = response.json()
    
        assert response.status_code == 200
>       assert data["failed"] == 1
               ^^^^^^^^^^^^^^
E       KeyError: 'failed'

tests\routes\test_relatos_progress.py:123: KeyError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:58:08,985", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:09,015", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Getting progress for relato_id=relato-123 user=user_123"}
{"timestamp": "2026-01-27 11:58:13,410", "level": "DEBUG", "logger": "urllib3.connectionpool", "message": "Starting new HTTPS connection (1): oauth2.googleapis.com:443"}
{"timestamp": "2026-01-27 11:58:13,661", "level": "DEBUG", "logger": "urllib3.connectionpool", "message": "https://oauth2.googleapis.com:443 \"POST /token HTTP/1.1\" 200 None"}
{"timestamp": "2026-01-27 11:58:13,786", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Found 26 effect records for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:13,786", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Converted effect records to UXEffectRecords for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:13,786", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Sorted UXEffectRecords for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:13,786", "level": "DEBUG", "logger": "app.core.projections.progress_projector", "message": "Projecting progress for relato_id=relato-123 with 26 effects"}
{"timestamp": "2026-01-27 11:58:13,786", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Projected progress for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:13,792", "level": "INFO", "logger": "root", "message": "GET /relatos/relato-123/progress 127.0.0.1 -> 200 (4782.1ms) body_len=0"}
{"timestamp": "2026-01-27 11:58:13,792", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/relatos/relato-123/progress \"HTTP/1.1 200 OK\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:58:13] [INFO] [request_logger] GET /relatos/relato-123/progress Status: 200 Tempo: 4782.09ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:58:13 [INFO] GET /relatos/relato-123/progress 127.0.0.1 -> 200 (4782.1ms) body_len=0
2026-01-27 11:58:13 [INFO] HTTP Request: GET http://test/relatos/relato-123/progress "HTTP/1.1 200 OK"
______________________ test_get_relato_progress_complete ______________________

client = <httpx.AsyncClient object at 0x0000023FAD537390>
mock_current_user_usuario_logado = None
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD537010>

    @pytest.mark.asyncio
    async def test_get_relato_progress_complete(
        client,
        mock_current_user_usuario_logado,
        monkeypatch,
    ):
        async def fake_get_relato_by_id(*_, **__):
            return {"id": "relato-123"}
    
        def fake_fetch_progress(relato_id: str):
            return {
                "relato_id": relato_id,
                "total_effects": 2,
                "completed": 2,
                "failed": 0,
                "progress_pct": 100,
                "effects": [
                    {"effect_type": "PERSIST_RELATO", "success": True},
                    {"effect_type": "UPLOAD_IMAGES", "success": True},
                ],
            }
    
        monkeypatch.setattr(
            "app.services.relatos_service.get_relato_by_id",
            fake_get_relato_by_id,
        )
    
        monkeypatch.setattr(
            "app.services.readmodels.relato_progress.fetch_relato_progress",
            fake_fetch_progress,
        )
    
        response = await client.get("/relatos/relato-123/progress")
        data = response.json()
    
        assert response.status_code == 200
>       assert data["progress_pct"] == 100
E       assert 0.42857142857142855 == 100

tests\routes\test_relatos_progress.py:167: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:58:13,813", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:13,832", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Getting progress for relato_id=relato-123 user=user_123"}
{"timestamp": "2026-01-27 11:58:17,739", "level": "DEBUG", "logger": "urllib3.connectionpool", "message": "Starting new HTTPS connection (1): oauth2.googleapis.com:443"}
{"timestamp": "2026-01-27 11:58:17,984", "level": "DEBUG", "logger": "urllib3.connectionpool", "message": "https://oauth2.googleapis.com:443 \"POST /token HTTP/1.1\" 200 None"}
{"timestamp": "2026-01-27 11:58:18,111", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Found 26 effect records for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:18,112", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Converted effect records to UXEffectRecords for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:18,112", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Sorted UXEffectRecords for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:18,112", "level": "DEBUG", "logger": "app.core.projections.progress_projector", "message": "Projecting progress for relato_id=relato-123 with 26 effects"}
{"timestamp": "2026-01-27 11:58:18,112", "level": "DEBUG", "logger": "app.routes.relatos_progress", "message": "Projected progress for relato_id=relato-123"}
{"timestamp": "2026-01-27 11:58:18,115", "level": "INFO", "logger": "root", "message": "GET /relatos/relato-123/progress 127.0.0.1 -> 200 (4282.7ms) body_len=0"}
{"timestamp": "2026-01-27 11:58:18,117", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/relatos/relato-123/progress \"HTTP/1.1 200 OK\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:58:18] [INFO] [request_logger] GET /relatos/relato-123/progress Status: 200 Tempo: 4281.21ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:58:18 [INFO] GET /relatos/relato-123/progress 127.0.0.1 -> 200 (4282.7ms) body_len=0
2026-01-27 11:58:18 [INFO] HTTP Request: GET http://test/relatos/relato-123/progress "HTTP/1.1 200 OK"
__________________________ test_retry_effect_success __________________________

    def test_retry_effect_success():
        clear_registry()
    
        mock_executor = Mock()
        register_effect_executor("UPLOAD_IMAGE", mock_executor)
    
        fake_result = EffectResult(
            relato_id="r1",
            effect_type="UPLOAD_IMAGE",
            effect_ref="img123",
            success=False,
            metadata={"path": "x/y.jpg"},
            error="fail",
            executed_at=datetime.utcnow(),
        )
    
>       with patch(
            "app.services.effects.retry_engine.load_effect_result",
            return_value=fake_result,
        ), patch(
            "app.services.effects.retry_engine.persist_effect_result_firestore"
        ):

tests\services\effects\test_retry_effect.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python311\Lib\unittest\mock.py:1443: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x0000023FAD2FC2D0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.effects.retry_engine' from 'D:\\workspace_projects_001\\dermasync-api\\app\\services\\effects\\retry_engine.py'> does not have the attribute 'load_effect_result'

C:\Python311\Lib\unittest\mock.py:1416: AttributeError
__________________ test_retry_effect_unsupported_type_raises __________________

    def test_retry_effect_unsupported_type_raises():
        clear_registry()
    
        fake_result = EffectResult(
            relato_id="r1",
            effect_type="UNKNOWN_EFFECT",
            effect_ref="x",
            success=False,
            metadata={},
            error="fail",
            executed_at=datetime.utcnow(),
        )
    
>       with patch(
            "app.services.effects.retry_engine.load_effect_result",
            return_value=fake_result,
        ):

tests\services\effects\test_retry_effect_unsupported.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python311\Lib\unittest\mock.py:1443: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x0000023FAD55AAD0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.effects.retry_engine' from 'D:\\workspace_projects_001\\dermasync-api\\app\\services\\effects\\retry_engine.py'> does not have the attribute 'load_effect_result'

C:\Python311\Lib\unittest\mock.py:1416: AttributeError
__________________________ test_retry_persist_relato __________________________

executor = <app.services.relato_effect_executor.RelatoEffectExecutor object at 0x0000023FAD57D890>

    def test_retry_persist_relato(executor):
        """
        Deve reexecutar PersistRelatoEffect a partir de EffectResult.
        """
        effect_data = {
            "owner_id": "user-123",
            "status": "novo",
            "conteudo": "conteudo",
            "imagens": {},
        }
        result = EffectResult(
            relato_id="relato-123",
            effect_type="PERSIST_RELATO",
            effect_ref="relato-123",
            success=False,
            metadata={"effect_data": effect_data},
        )
    
>       executor.execute_by_result(effect_result=result, attempt=1)

tests\services\effects\test_retry_executor.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.services.relato_effect_executor.RelatoEffectExecutor object at 0x0000023FAD57D890>

    def execute_by_result(
        self,
        *,
        effect_result: EffectResult,
        attempt: int,
    ):
        """
        Reexecuta um efeito com base em um EffectResult anterior.
        N├âO decide retry.
        N├âO muda dom├¡nio.
        """
    
        effect_type = effect_result.effect_type
        relato_id = effect_result.relato_id
    
        logger.info(
            "RetryExecutor | effect=%s | relato=%s | attempt=%d",
            effect_type,
            relato_id,
            attempt,
        )
    
        # Reconstru├º├úo m├¡nima do efeito
        if effect_type == "PERSIST_RELATO":
            effect_data = effect_result.metadata.get("effect_data", {})
>           effect = PersistRelatoEffect(relato_id=relato_id, **effect_data)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: PersistRelatoEffect.__init__() got an unexpected keyword argument 'imagens'

app\services\relato_effect_executor.py:376: TypeError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:18,738", "level": "INFO", "logger": "app.services.relato_effect_executor", "message": "RetryExecutor | effect=PERSIST_RELATO | relato=relato-123 | attempt=1"}
------------------------------ Captured log call ------------------------------
2026-01-27 11:58:18 [INFO] RetryExecutor | effect=PERSIST_RELATO | relato=relato-123 | attempt=1
____________________________ test_retry_emit_event ____________________________

executor = <app.services.relato_effect_executor.RelatoEffectExecutor object at 0x0000023FAD137A90>

    def test_retry_emit_event(executor):
        """
        Deve reexecutar EmitDomainEventEffect com payload preservado.
        """
        result = EffectResult(
            relato_id="relato-789",
            effect_type="EMIT_EVENT",
            effect_ref="relato_criado",
            success=False,
            metadata={
                "payload": {"relato_id": "relato-789", "foo": "bar"}
            },
        )
    
>       executor.execute_by_result(effect_result=result, attempt=1)

tests\services\effects\test_retry_executor.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
app\services\relato_effect_executor.py:408: in execute_by_result
    raise exc
app\services\relato_effect_executor.py:400: in execute_by_result
    self.execute([effect])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.services.relato_effect_executor.RelatoEffectExecutor object at 0x0000023FAD137A90>
effects = [EmitDomainEventEffect(event_name='relato_criado', payload={'relato_id': 'relato-789', 'foo': 'bar'})]

    def execute(self, effects: list):
        logger.info("Executando efeitos do relato | total=%d", len(effects))
    
        executed_effects: list = []
    
        try:
            for effect in effects:
                # =====================================================
                # Idempot├¬ncia ÔÇö skip se j├í executado com sucesso
                # =====================================================
                effect_type = effect.__class__.__name__
    
                if isinstance(effect, UpdateRelatoStatusEffect):
                    effect_ref = effect.new_status.value
                elif isinstance(effect, EmitDomainEventEffect):
                    effect_ref = effect.event_name
                else:
                    effect_ref = effect.relato_id
    
                if effect_ref and effect_already_succeeded(
>                   relato_id=effect.relato_id,
                              ^^^^^^^^^^^^^^^^
                    effect_type=effect_type,
                    effect_ref=effect_ref,
                ):
E               AttributeError: 'EmitDomainEventEffect' object has no attribute 'relato_id'

app\services\relato_effect_executor.py:70: AttributeError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:18,909", "level": "INFO", "logger": "app.services.relato_effect_executor", "message": "RetryExecutor | effect=EMIT_EVENT | relato=relato-789 | attempt=1"}
{"timestamp": "2026-01-27 11:58:18,910", "level": "INFO", "logger": "app.services.relato_effect_executor", "message": "Executando efeitos do relato | total=1"}
{"timestamp": "2026-01-27 11:58:18,910", "level": "WARNING", "logger": "app.services.relato_effect_executor", "message": "Falha na execu├º├úo de efeitos. Iniciando rollback compensat├│rio | total_executados=0"}
{"timestamp": "2026-01-27 11:58:18,911", "level": "ERROR", "logger": "app.services.relato_effect_executor", "message": "RetryExecutor | falha ao reexecutar effect=EMIT_EVENT | relato=relato-789"}
------------------------------ Captured log call ------------------------------
2026-01-27 11:58:18 [INFO] RetryExecutor | effect=EMIT_EVENT | relato=relato-789 | attempt=1
2026-01-27 11:58:18 [INFO] Executando efeitos do relato | total=1
2026-01-27 11:58:18 [WARNING] Falha na execu├º├úo de efeitos. Iniciando rollback compensat├│rio | total_executados=0
2026-01-27 11:58:18 [ERROR] RetryExecutor | falha ao reexecutar effect=EMIT_EVENT | relato=relato-789
Traceback (most recent call last):
  File "D:\workspace_projects_001\dermasync-api\app\services\relato_effect_executor.py", line 400, in execute_by_result
    self.execute([effect])
  File "D:\workspace_projects_001\dermasync-api\app\services\relato_effect_executor.py", line 70, in execute
    relato_id=effect.relato_id,
              ^^^^^^^^^^^^^^^^
AttributeError: 'EmitDomainEventEffect' object has no attribute 'relato_id'
______________________ test_retry_upload_images_success _______________________

executor = <app.services.relato_effect_executor.RelatoEffectExecutor object at 0x0000023FAD2E6910>

    def test_retry_upload_images_success(executor):
        """
        Deve reexecutar UploadImagesEffect quando metadata.imagens existe.
        """
        imagens = {
            "antes": ["img1"],
            "durante": ["img2", "img3"],
            "depois": [],
        }
    
        result = EffectResult(
            relato_id="relato-999",
            effect_type="UPLOAD_IMAGES",
            effect_ref="relato-999",
            success=False,
            metadata={
                "imagens": imagens
            },
        )
    
>       executor.execute_by_result(effect_result=result, attempt=2)

tests\services\effects\test_retry_executor.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.services.relato_effect_executor.RelatoEffectExecutor object at 0x0000023FAD2E6910>

    def execute_by_result(
        self,
        *,
        effect_result: EffectResult,
        attempt: int,
    ):
        """
        Reexecuta um efeito com base em um EffectResult anterior.
        N├âO decide retry.
        N├âO muda dom├¡nio.
        """
    
        effect_type = effect_result.effect_type
        relato_id = effect_result.relato_id
    
        logger.info(
            "RetryExecutor | effect=%s | relato=%s | attempt=%d",
            effect_type,
            relato_id,
            attempt,
        )
    
        # Reconstru├º├úo m├¡nima do efeito
        if effect_type == "PERSIST_RELATO":
            effect_data = effect_result.metadata.get("effect_data", {})
            effect = PersistRelatoEffect(relato_id=relato_id, **effect_data)
    
        elif effect_type == "ENQUEUE_PROCESSING":
            effect = EnqueueProcessingEffect(relato_id=relato_id)
    
        elif effect_type == "EMIT_EVENT":
            effect = EmitDomainEventEffect(
                event_name=effect_result.effect_ref,
                payload=effect_result.metadata.get("payload") if effect_result.metadata else None,
            )
    
        elif effect_type == "UPLOAD_IMAGES":
            # TODO: suportar retry quando upload for idempotente (hash + versionamento)
>           raise ValueError(
                "Retry autom├ítico de UPLOAD_IMAGES n├úo ├® suportado. "
                "Uploads n├úo s├úo idempotentes sem controle de storage."
            )
E           ValueError: Retry autom├ítico de UPLOAD_IMAGES n├úo ├® suportado. Uploads n├úo s├úo idempotentes sem controle de storage.

app\services\relato_effect_executor.py:389: ValueError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:18,974", "level": "INFO", "logger": "app.services.relato_effect_executor", "message": "RetryExecutor | effect=UPLOAD_IMAGES | relato=relato-999 | attempt=2"}
------------------------------ Captured log call ------------------------------
2026-01-27 11:58:18 [INFO] RetryExecutor | effect=UPLOAD_IMAGES | relato=relato-999 | attempt=2
___________________________ test_progress_ui_empty ____________________________

    def test_progress_ui_empty():
        progress = {
            "total_effects": 0,
            "completed": 0,
            "failed": 0,
            "progress_pct": 0,
            "effects": [],
        }
    
        ui = build_relato_progress_ui(
            relato_id="relato-1",
            progress=progress,
        )
    
>       assert ui["status"] == "PENDING"
E       AssertionError: assert 'RECEIVED' == 'PENDING'
E         
E         - PENDING
E         + RECEIVED

tests\services\readmodels\test_relato_progress_ui.py:24: AssertionError
_____________________ test_progress_ui_partial_with_error _____________________

    def test_progress_ui_partial_with_error():
        progress = {
            "total_effects": 3,
            "completed": 2,
            "failed": 1,
            "progress_pct": 66,
            "effects": [
                {"effect_type": "PERSIST_RELATO", "success": True},
                {"effect_type": "UPLOAD_IMAGES", "success": False},
                {"effect_type": "ENQUEUE_PROCESSING", "success": True},
            ],
        }
    
        ui = build_relato_progress_ui(
            relato_id="relato-2",
            progress=progress,
        )
    
        assert ui["status"] == "PARTIAL_ERROR"
        assert ui["progress_pct"] == 66
>       assert ui["failed"] == 1
               ^^^^^^^^^^^^
E       KeyError: 'failed'

tests\services\readmodels\test_relato_progress_ui.py:54: KeyError
________________________ test_progress_ui_in_progress _________________________

    def test_progress_ui_in_progress():
        progress = {
            "total_effects": 3,
            "completed": 1,
            "failed": 0,
            "progress_pct": 33,
            "effects": [
                {"effect_type": "PERSIST_RELATO", "success": True},
            ],
        }
    
        ui = build_relato_progress_ui(
            relato_id="relato-3",
            progress=progress,
        )
    
>       assert ui["status"] == "IN_PROGRESS"
E       AssertionError: assert 'PROCESSING' == 'IN_PROGRESS'
E         
E         - IN_PROGRESS
E         + PROCESSING

tests\services\readmodels\test_relato_progress_ui.py:81: AssertionError
_________________________ test_progress_ui_completed __________________________

    def test_progress_ui_completed():
        progress = {
            "total_effects": 2,
            "completed": 2,
            "failed": 0,
            "progress_pct": 100,
            "effects": [
                {"effect_type": "PERSIST_RELATO", "success": True},
                {"effect_type": "UPLOAD_IMAGES", "success": True},
            ],
        }
    
        ui = build_relato_progress_ui(
            relato_id="relato-4",
            progress=progress,
        )
    
        assert ui["status"] == "COMPLETED"
        assert ui["progress_pct"] == 100
>       assert ui["failed"] == 0
               ^^^^^^^^^^^^
E       KeyError: 'failed'

tests\services\readmodels\test_relato_progress_ui.py:110: KeyError
_______________ test_executor_skips_effect_if_already_succeeded _______________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000023FAD585950>

    def test_executor_skips_effect_if_already_succeeded(monkeypatch):
        """
        Prova que o executor N├âO executa novamente
        um efeito que j├í possui EffectResult success=True.
        """
    
        from app.services.relato_effect_executor import RelatoEffectExecutor
        from app.domain.relato.effects import UploadImagesEffect
    
        # -----------------------------
        # Controle de chamadas
        # -----------------------------
        upload_call_count = 0
    
        def fake_upload(relato_id, imagens):
            nonlocal upload_call_count
            upload_call_count += 1
            return ["img-1", "img-2"]
    
        # -----------------------------
        # Simula idempot├¬ncia ativa
        # -----------------------------
        def fake_effect_already_succeeded(*, relato_id, effect_type, effect_ref):
            # Simula que o efeito J├ü FOI executado com sucesso
            return True
    
        monkeypatch.setattr(
            "app.services.relato_effect_executor.effect_already_succeeded",
            fake_effect_already_succeeded,
        )
    
    
        # -----------------------------
        # Executor real
        # -----------------------------
        executor = RelatoEffectExecutor(
            upload_images=fake_upload,
            rollback_images=None,
            persist_relato=lambda **_: None,
            enqueue_processing=lambda *_: None,
            emit_event=lambda *_: None,
            update_relato_status=lambda *_: None,
        )
    
        effects = [
>           UploadImagesEffect(
                relato_id="relato-123",
                imagens={"antes": [], "durante": [], "depois": []},
            )
        ]
E       TypeError: UploadImagesEffect.__init__() got an unexpected keyword argument 'imagens'

tests\services\test_executor_idempotency.py:48: TypeError
________________________ test_ux_effect_contract_shape ________________________

    def test_ux_effect_contract_shape():
        effect = RetryUXEffect.none_needed(relato_id="r1")
    
>       data = serialize_ux_effects([effect])[0]
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       IndexError: list index out of range

tests\services\test_ux_effects.py:11: IndexError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:19,174", "level": "DEBUG", "logger": "app.services.ux_adapters", "message": "Ignoring non-UX domain effect: RetryUXEffect"}
_________________ test_processing_started_ux_effect_contract __________________

    def test_processing_started_ux_effect_contract():
        effect = ProcessingStartedUXEffect.default(relato_id="r1")
    
>       data = serialize_ux_effects([effect])[0]
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       IndexError: list index out of range

tests\services\test_ux_effects.py:24: IndexError
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:19,207", "level": "DEBUG", "logger": "app.services.ux_adapters", "message": "Ignoring non-UX domain effect: ProcessingStartedUXEffect"}
_________________________ test_get_imagem_signed_url __________________________

client = <httpx.AsyncClient object at 0x0000023FAE79C950>
mock_current_user_usuario_logado = None
mocker = <pytest_mock.plugin.MockerFixture object at 0x0000023FAE79CC50>

    @pytest.mark.asyncio
    async def test_get_imagem_signed_url(
        client: AsyncClient, mock_current_user_usuario_logado, mocker
    ):
        """
        Testa se a rota GET /imagens/{image_id} retorna um URL assinado.
        """
        # Mock para get_imagem_by_id com todos os campos necess├írios para ImagemMetadata
        mocker.patch(
            "app.routes.imagens.get_imagem_by_id",
            return_value={
                "id": "image_123",
                "owner_user_id": "user_123", # MODIFIED to align with default mock user
                "status": "raw",
                "original_filename": "some_image.jpg",
                "content_type": "image/jpeg",
                "size_bytes": 1024,
                "width": 100,
                "height": 100,
                "sha256": "somehash",
                "storage_path": "raw/user_123/some_image.jpg", # MODIFIED
                "created_at": "2023-01-01T00:00:00Z",
                "updated_at": "2023-01-01T00:00:00Z",
            },
        )
    
        # Mock para get_imagem_signed_url
        mock_get_signed_url = mocker.patch(
            "app.routes.imagens.get_imagem_signed_url",
            return_value="https://storage.googleapis.com/fake-bucket/raw/user_123/some_image.jpg?Signature=123", # MODIFIED
        )
    
        response = await client.get("/imagens/image_123")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\test_imagens_avancado.py:81: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:58:20,566", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:20,584", "level": "INFO", "logger": "root", "message": "GET /imagens/image_123 127.0.0.1 -> 404 (0.0ms) body_len=0"}
{"timestamp": "2026-01-27 11:58:20,584", "level": "INFO", "logger": "httpx", "message": "HTTP Request: GET http://test/imagens/image_123 \"HTTP/1.1 404 Not Found\""}
---------------------------- Captured stderr call -----------------------------
[32m[2026-01-27 11:58:20] [INFO] [request_logger] GET /imagens/image_123 Status: 404 Tempo: 0.00ms[0m
------------------------------ Captured log call ------------------------------
2026-01-27 11:58:20 [INFO] GET /imagens/image_123 127.0.0.1 -> 404 (0.0ms) body_len=0
2026-01-27 11:58:20 [INFO] HTTP Request: GET http://test/imagens/image_123 "HTTP/1.1 404 Not Found"
__________________ test_enriquecer_metadados_formato_valido ___________________

    @pytest.mark.asyncio
    async def test_enriquecer_metadados_formato_valido():
        # === Mock de um relato bruto ===
        relato_bruto = {
            "id_relato": "abc123def456ghi789xyz",
            "origem": "facebook",
            "data_modificacao": datetime.utcnow().isoformat(),
            "conteudo_original": "Ol├í meus amores. Tenho dermatite at├│pica nas pernas e usei cetirizina por 3 dias e vaselina por mais 7 dias. Melhorei bastante, mas ainda sinto coceira ocasional.",
            "versao_pipeline": "v0.0.1",
            "origem": {
                "plataforma": "facebook",
                "link": "https://facebook.com/groups/dermatite/posts/123456789",
                "tipo": "comentario",
                "data_postagem": None,
                "grupo": "Dermatite At├│pica Brasil",
                "usuario_aparente": None,
            },
        }
    
        # === Processa ===
        enriquecido = processar_relato(relato_real)
        logger.debug("Relato enriquecido: %s", enriquecido)
        # === Valida campos obrigat├│rios ===
>       assert "idade" in enriquecido
E       AssertionError: assert 'idade' in {'conteudo_anonimizado': None, 'conteudo_original': 'Queridos, tudo bom?\nra os Cetaphil Lo├º├úo hidratante 473 ml ou Lipikar Lo├º├úo 400 ml) s├úo os meus preferidos. \n\nPrimeiro porque n├úo tem cheiro.\nSegundoleve. ( detesto coisa pegajosa!)\n\nPara enriquecer a formula├º├úo, escolhi:\n\n 50 ml do Bepantol solu├º├úo, vitamina B5  ( quem disse que ele s├│ serve para os cabelos??)\n50 ml de ├ôleo de semente de uva para diminuir a perda de ├ígua para o meio externo e repor antioxidantes para a pele ( rejuvenescedor)\n40 ml ( 1 frasco) do Cicaplast para aumentar a regenera├º├úo e recompor a barreira cut├ónea.\n\nMisture tudo ( vocc├¬ vai ter aproximadamente 550 ml de hidratante ) e mantenha em um frasco pump profissional de 600 ml ou mais  que voc├¬ encontra em loja de sal├úo de beleza e aplique  na pele corporal do pesco├ºo aos p├®', 'data_modificacao': '2025-06-10T07:58:35.656562', 'id_relato': '5ab7a3b6132f409aacd90a3097ad4ceb', ...}

tests\test_pipeline_02_enriquecer_metadados.py:58: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:58:22,919", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:27,397", "level": "INFO", "logger": "app.pipeline.B_enriquecimento.enriquecer_metadados", "message": "Usando cliente LLM: <app.pipeline.llm_client.gemini_client.GeminiClient object at 0x0000023FAD235E10>"}
{"timestamp": "2026-01-27 11:58:27,402", "level": "INFO", "logger": "app.pipeline.B_enriquecimento.enriquecer_metadados", "message": "Enviando prompt para LLM..."}
{"timestamp": "2026-01-27 11:58:27,842", "level": "ERROR", "logger": "app.pipeline.B_enriquecimento.enriquecer_metadados", "message": "Erro ao processar relato: 404 models/gemini is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods."}
{"timestamp": "2026-01-27 11:58:27,842", "level": "DEBUG", "logger": "tests.test_pipeline_02_enriquecer_metadados", "message": "Relato enriquecido: {'id_relato': '5ab7a3b6132f409aacd90a3097ad4ceb', 'origem': {'plataforma': 'facebook', 'link': None, 'tipo': 'comentario', 'ano_postagem': None, 'grupo': 'Dermatite At├│pica Brasil', 'ctx_id': '1234567890'}, 'versao_pipeline': 'v0.0.1', 'data_modificacao': '2025-06-10T07:58:35.656562', 'conteudo_original': 'Queridos, tudo bom?\\nra os Cetaphil Lo├º├úo hidratante 473 ml ou Lipikar Lo├º├úo 400 ml) s├úo os meus preferidos. \\n\\nPrimeiro porque n├úo tem cheiro.\\nSegundoleve. ( detesto coisa pegajosa!)\\n\\nPara enriquecer a formula├º├úo, escolhi:\\n\\n 50 ml do Bepantol solu├º├úo, vitamina B5  ( quem disse que ele s├│ serve para os cabelos??)\\n50 ml de ├ôleo de semente de uva para diminuir a perda de ├ígua para o meio externo e repor antioxidantes para a pele ( rejuvenescedor)\\n40 ml ( 1 frasco) do Cicaplast para aumentar a regenera├º├úo e recompor a barreira cut├ónea.\\n\\nMisture tudo ( vocc├¬ vai ter aproximadamente 550 ml de hidratante ) e mantenha em um frasco pump profissional de 600 ml ou mais  que voc├¬ encontra em loja de sal├úo de beleza e aplique  na pele corporal do pesco├ºo aos p├®', 'tags_extraidas': [], 'conteudo_anonimizado': None, 'llm_processamento': {'inicio': '2026-01-27T14:58:22.937863', 'fim': '2026-01-27T14:58:27.842952', 'duracao_ms': 4905, 'tentativas': 1, 'erro': '404 models/gemini is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.', 'modelo': 'gemini'}, 'status_llm': 'erro'}"}
------------------------------ Captured log call ------------------------------
2026-01-27 11:58:27 [INFO] Usando cliente LLM: <app.pipeline.llm_client.gemini_client.GeminiClient object at 0x0000023FAD235E10>
2026-01-27 11:58:27 [INFO] Enviando prompt para LLM...
2026-01-27 11:58:27 [ERROR] Erro ao processar relato: 404 models/gemini is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.
________________________ test_integracao_fase_01_e_02 _________________________

    @pytest.mark.asyncio
    async def test_integracao_fase_01_e_02():
        from jsonschema import validate
    
        from app.pipeline.a_extracao_bruta.gerar_jsonl_bruto import \
            gerar_jsonl_bruto
        from app.pipeline.B_enriquecimento.enriquecer_metadados import \
            processar_relato
    
        schema_path = Path("./app/schema/relato_schema.json")
        assert schema_path.exists(), "Schema JSON n├úo encontrado."
        with open(schema_path, "r", encoding="utf-8") as f:
            schema = json.load(f)
    
        # === Etapa 1: Gerar JSONL bruto ===
        with tempfile.TemporaryDirectory() as tmpdir:
            txt_path = Path(tmpdir) / "teste_relato.txt"
            txt_path.write_text(
                "Tenho 35 anos e usei Cetaphil por 10 dias. Ajudou bastante nas coceiras."
            )
    
            output_jsonl = Path(tmpdir) / "saida.jsonl"
            await gerar_jsonl_bruto(
                {
                    "origem": "facebook",
                    "src_dir": tmpdir,
                    "ctx_id": "CTX1234567890",
                    "grupo": "Grupo de Teste",
                    "tipo": "comentario",
                },
                output_path=output_jsonl,
            )
    
            assert output_jsonl.exists(), "Arquivo JSONL bruto n├úo foi gerado."
    
            linhas = output_jsonl.read_text().splitlines()
            assert len(linhas) == 1, "Deveria conter um ├║nico relato gerado."
    
            relato_bruto = json.loads(linhas[0])
            assert isinstance(relato_bruto, dict)
    
            # === Etapa 2: Enriquecer relato ===
            enriquecido = processar_relato(relato_bruto)
            assert isinstance(enriquecido, dict)
    
            # === Checa campos esperados ap├│s enriquecimento ===
            for campo in [
                "idade",
                "genero",
                "classificacao_etaria",
                "llm_processamento",
                "status_llm",
            ]:
>               assert campo in enriquecido, f"Campo {campo} ausente ap├│s enriquecimento."
E               AssertionError: Campo idade ausente ap├│s enriquecimento.
E               assert 'idade' in {'conteudo_anonimizado': None, 'conteudo_original': 'Tenho 35 anos e usei Cetaphil por 10 dias. Ajudou bastante nas coceiras.', 'data_modificacao': '2026-01-27T11:58:28.019064', 'id_relato': '14092dda1b264f16864c6d930c8a2939', ...}

tests\test_pipeline_integracao_01_02.py:65: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"timestamp": "2026-01-27 11:58:27,988", "level": "DEBUG", "logger": "asyncio", "message": "Using proactor: IocpProactor"}
---------------------------- Captured stdout call -----------------------------
{"timestamp": "2026-01-27 11:58:28,020", "level": "INFO", "logger": "app.pipeline.a_extracao_bruta.gerar_jsonl_bruto", "message": "Iniciando a gera├º├úo do JSONL bruto..."}
{"timestamp": "2026-01-27 11:58:28,021", "level": "INFO", "logger": "app.pipeline.a_extracao_bruta.gerar_jsonl_bruto", "message": "Par├ómetros de entrada: {'origem': 'facebook', 'src_dir': 'C:\\\\Users\\\\JEFFER~1\\\\AppData\\\\Local\\\\Temp\\\\tmpbv4u9b4c', 'ctx_id': 'CTX1234567890', 'grupo': 'Grupo de Teste', 'tipo': 'comentario'}, C:\\Users\\JEFFER~1\\AppData\\Local\\Temp\\tmpbv4u9b4c\\saida.jsonl"}
­ƒôé Lendo arquivos do diret├│rio: C:\Users\JEFFER~1\AppData\Local\Temp\tmpbv4u9b4c (facebook)
­ƒÆ¥ 1 registros salvos em C:\Users\JEFFER~1\AppData\Local\Temp\tmpbv4u9b4c\saida.jsonl
{"timestamp": "2026-01-27 11:58:28,027", "level": "INFO", "logger": "app.pipeline.B_enriquecimento.enriquecer_metadados", "message": "Usando cliente LLM: <app.pipeline.llm_client.gemini_client.GeminiClient object at 0x0000023FAE7639D0>"}
{"timestamp": "2026-01-27 11:58:28,027", "level": "INFO", "logger": "app.pipeline.B_enriquecimento.enriquecer_metadados", "message": "Enviando prompt para LLM..."}
{"timestamp": "2026-01-27 11:58:28,414", "level": "ERROR", "logger": "app.pipeline.B_enriquecimento.enriquecer_metadados", "message": "Erro ao processar relato: 404 models/gemini is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods."}
------------------------------ Captured log call ------------------------------
2026-01-27 11:58:28 [INFO] Iniciando a gera├º├úo do JSONL bruto...
2026-01-27 11:58:28 [INFO] Par├ómetros de entrada: {'origem': 'facebook', 'src_dir': 'C:\\Users\\JEFFER~1\\AppData\\Local\\Temp\\tmpbv4u9b4c', 'ctx_id': 'CTX1234567890', 'grupo': 'Grupo de Teste', 'tipo': 'comentario'}, C:\Users\JEFFER~1\AppData\Local\Temp\tmpbv4u9b4c\saida.jsonl
2026-01-27 11:58:28 [INFO] Usando cliente LLM: <app.pipeline.llm_client.gemini_client.GeminiClient object at 0x0000023FAE7639D0>
2026-01-27 11:58:28 [INFO] Enviando prompt para LLM...
2026-01-27 11:58:28 [ERROR] Erro ao processar relato: 404 models/gemini is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.
________________ test_user_sees_coherent_story_from_ux_effects ________________

    def test_user_sees_coherent_story_from_ux_effects():
        relato_id = "123"
    
        effects = [
            ProcessingStartedUXEffect.default(relato_id=relato_id),
            RetryUXEffect.retrying(relato_id=relato_id, count=1),
            RetryUXEffect.retrying(relato_id=relato_id, count=2),
            RetryUXEffect.failed_final(relato_id=relato_id),
        ]
    
        serialized_effects = [e.serialize() for e in effects]
    
        ui_story = interpret_for_ui(serialized_effects)
    
>       assert ui_story == [
            "Recebemos seu relato",
            "Tentando novamente...",
            "Tentando novamente...",
            "N├úo foi poss├¡vel concluir agora",
        ]
E       AssertionError: assert ['Recebemos s...ncluir agora'] == ['Recebemos s...ncluir agora']
E         
E         At index 1 diff: 'N├úo foi poss├¡vel concluir agora' != 'Tentando novamente...'
E         Right contains 2 more items, first extra item: 'Tentando novamente...'
E         
E         Full diff:
E           [
E               'Recebemos seu relato',...
E         
E         ...Full output truncated (4 lines hidden), use '-vv' to show

tests\ux\test_cognitive_integration_flow.py:30: AssertionError
============================== warnings summary ===============================
tests\auth\test_auth_hardening.py:29
  d:\workspace_projects_001\dermasync-api\tests\auth\test_auth_hardening.py:29: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests\auth\test_auth_hardening.py:56
  d:\workspace_projects_001\dermasync-api\tests\auth\test_auth_hardening.py:56: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests\auth\test_auth_hardening.py:79
  d:\workspace_projects_001\dermasync-api\tests\auth\test_auth_hardening.py:79: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/auth/test_auth_hardening.py::test_auth_refresh_expired
  D:\workspace_projects_001\dermasync-api\venv\Lib\site-packages\passlib\handlers\argon2.py:716: DeprecationWarning: Accessing argon2.__version__ is deprecated and will be removed in a future release. Use importlib.metadata directly to query for argon2-cffi's packaging metadata.
    _argon2_cffi.__version__, max_version)

tests/integration/test_relato_progress_firestore.py::test_effect_result_repository_reads_from_firestore
tests/integration/test_relato_progress_firestore.py::test_progress_service_with_firestore_emulator
tests/routes/test_relatos_progress.py::test_get_relato_progress_forbidden
tests/routes/test_relatos_progress.py::test_get_relato_progress_empty
tests/routes/test_relatos_progress.py::test_get_relato_progress_partial_with_error
tests/routes/test_relatos_progress.py::test_get_relato_progress_complete
  D:\workspace_projects_001\dermasync-api\venv\Lib\site-packages\google\cloud\firestore_v1\base_collection.py:304: UserWarning: Detected filter using positional arguments. Prefer using the 'filter' keyword argument instead.
    return query.where(field_path, op_string, value)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
--------------------------------- JSON report ---------------------------------
report saved to: report.json
=============================== tests coverage ================================
_______________ coverage: platform win32, python 3.11.4-final-0 _______________

Coverage HTML written to dir htmlcov
=========================== short test summary info ===========================
FAILED tests/application/test_relato_progress_stabilization_service.py::test_job_persists_snapshot_when_progress_is_stable
FAILED tests/domain/effects/test_retry_ux_effects.py::test_retry_endpoint_returns_ux_effect
FAILED tests/domain/enrichment/test_enriched_metadata_v2_validator.py::test_valid_payload_passes_validation
FAILED tests/domain/enrichment/test_enriched_metadata_v2_validator.py::test_extra_field_fails
FAILED tests/domain/relato/test_create_relato.py::test_criar_relato_estado_inicial
FAILED tests/domain/relato/test_create_relato.py::test_negar_criacao_relato_existente
FAILED tests/domain/relato/test_create_relato.py::test_post_relatos_success_runs_domain_and_executes_effects
FAILED tests/domain/relato/test_create_relato.py::test_create_relato_emits_typed_effects
FAILED tests/domain/relato/test_create_relato.py::test_create_relato_initial_state_is_created
FAILED tests/domain/relato/test_create_relato_decision.py::test_create_relato_allowed_from_initial_state
FAILED tests/domain/relato/test_create_relato_decision.py::test_create_relato_denied_when_already_exists
FAILED tests/domain/relato/test_create_relato_decision.py::test_create_relato_denied_from_any_existing_state
FAILED tests/domain/relato/test_create_relato_decision.py::test_create_relato_effects_structure
FAILED tests/domain/relato/test_invalid_transitions.py::test_negar_aprovacao_estado_draft
FAILED tests/domain/relato/test_invalid_transitions.py::test_negar_rejeicao_estado_draft
FAILED tests/domain/relato/test_invalid_transitions.py::test_negar_marcar_como_processado_estado_draft
FAILED tests/domain/relato/test_submit_relato.py::test_submeter_relato_estado_draft
FAILED tests/domain/ux_effects/test_ux_effect_public_contract.py::test_ux_effect_public_contract_snapshot
FAILED tests/domain/ux_effects/test_ux_effects_composition.py::test_multiple_ux_effects_preserve_order_and_contract
FAILED tests/domain/ux_progress/test_ux_progress.py::test_persist_relato_marks_first_step_done
FAILED tests/domain/ux_progress/test_ux_progress.py::test_upload_images_becomes_active_when_effect_exists_but_not_completed
FAILED tests/domain/ux_progress/test_ux_progress.py::test_upload_images_has_more_weight_in_progress
FAILED tests/domain/ux_progress/test_ux_progress.py::test_error_in_any_step_sets_has_error
FAILED tests/domain/ux_progress/test_ux_progress.py::test_all_steps_done_marks_progress_complete
FAILED tests/integration/test_relato_progress_firestore.py::test_effect_result_repository_reads_from_firestore
FAILED tests/relato/test_relato_update_status_sync.py::test_update_status_success
FAILED tests/relato/test_relato_update_status_sync.py::test_update_status_relato_not_found
FAILED tests/relato/test_relato_update_status_sync.py::test_background_error_sets_status_error
FAILED tests/relato/test_relato_update_status_sync.py::test_relato_state_progression
FAILED tests/relato/test_relato_update_status_sync.py::test_invalid_status_transition_raises
FAILED tests/relato/test_relato_update_status_sync.py::test_error_is_terminal
FAILED tests/relato/test_relatos.py::test_get_relatos_com_autenticacao_permitida
FAILED tests/relato/test_relatos.py::test_get_relatos_com_autenticacao_negada
FAILED tests/relato/test_relatos_admin.py::test_get_relatos_com_admin - asser...
FAILED tests/relato/test_relatos_avancado.py::test_enviar_relato_falha_firestore_rollback
FAILED tests/relato/test_relatos_avancado.py::test_get_my_relatos - assert 40...
FAILED tests/relato/test_relatos_avancado.py::test_get_single_relato_as_owner
FAILED tests/relato/test_relatos_avancado.py::test_attach_image_to_relato - a...
FAILED tests/relato/test_relatos_avancado.py::test_get_moderation_pending - a...
FAILED tests/relato/test_relatos_avancado.py::test_update_relato_status - ass...
FAILED tests/relato/test_relatos_enviar.py::test_enviar_relato_sem_autenticacao
FAILED tests/relato/test_relatos_enviar.py::test_enviar_relato_com_autenticacao
FAILED tests/routes/test_relatos_multipart.py::test_post_relatos_with_real_multipart_upload
FAILED tests/routes/test_relatos_multipart.py::test_upload_failure_triggers_rollback
FAILED tests/routes/test_relatos_post.py::test_post_relatos_success - Attribu...
FAILED tests/routes/test_relatos_post.py::test_post_relatos_denied_by_domain
FAILED tests/routes/test_relatos_post.py::test_post_relatos_missing_consentimento
FAILED tests/routes/test_relatos_post.py::test_post_relatos_no_consentimento_field
FAILED tests/routes/test_relatos_post.py::test_post_relatos_executor_not_called_when_denied
FAILED tests/routes/test_relatos_progress.py::test_get_relato_progress_forbidden
FAILED tests/routes/test_relatos_progress.py::test_get_relato_progress_empty
FAILED tests/routes/test_relatos_progress.py::test_get_relato_progress_partial_with_error
FAILED tests/routes/test_relatos_progress.py::test_get_relato_progress_complete
FAILED tests/services/effects/test_retry_effect.py::test_retry_effect_success
FAILED tests/services/effects/test_retry_effect_unsupported.py::test_retry_effect_unsupported_type_raises
FAILED tests/services/effects/test_retry_executor.py::test_retry_persist_relato
FAILED tests/services/effects/test_retry_executor.py::test_retry_emit_event
FAILED tests/services/effects/test_retry_executor.py::test_retry_upload_images_success
FAILED tests/services/readmodels/test_relato_progress_ui.py::test_progress_ui_empty
FAILED tests/services/readmodels/test_relato_progress_ui.py::test_progress_ui_partial_with_error
FAILED tests/services/readmodels/test_relato_progress_ui.py::test_progress_ui_in_progress
FAILED tests/services/readmodels/test_relato_progress_ui.py::test_progress_ui_completed
FAILED tests/services/test_executor_idempotency.py::test_executor_skips_effect_if_already_succeeded
FAILED tests/services/test_ux_effects.py::test_ux_effect_contract_shape - Ind...
FAILED tests/services/test_ux_effects.py::test_processing_started_ux_effect_contract
FAILED tests/test_imagens_avancado.py::test_get_imagem_signed_url - assert 40...
FAILED tests/test_pipeline_02_enriquecer_metadados.py::test_enriquecer_metadados_formato_valido
FAILED tests/test_pipeline_integracao_01_02.py::test_integracao_fase_01_e_02
FAILED tests/ux/test_cognitive_integration_flow.py::test_user_sees_coherent_story_from_ux_effects
=========== 69 failed, 106 passed, 10 warnings in 72.61s (0:01:12) ============
­ƒº╣ Limpando relat├│rios anteriores...
Ô£à Rodando Pytest com cobertura e relat├│rio JSON...


­ƒôè Resumo dos testes:
   Ô£à Passaram: 106
   ÔØî Falharam: 69
   ­ƒº¬ Total:     175

­ƒÜ¿ Alguns testes falharam. Verifique detalhes no report.json e logs_testes.jsonl

­ƒôé Abrindo relat├│rio de cobertura: D:\workspace_projects_001\dermasync-api\htmlcov\index.html

ÔØî Execu├º├úo finalizada com falhas.
